[TOC]
# 动态规划
## 多重背包
```
/*https://www.acwing.com/problem/content/5/*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e3+10,M=2e3+10;
int f[M],g[M],q[M];
int n,m;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        memcpy(g,f,sizeof f);
        int v,w,s;
        cin>>v>>w>>s;
        for(int j=0;j<v;++j){
            int hh=0,tt=0;
            for(int k=j;k<=m;k+=v){
                while(hh<tt&&q[hh]<k-s*v)hh++;
                if(hh<tt)f[k]=max(g[k],g[q[hh]]+(k-q[hh])/v*w);
                while(hh<tt&&g[k]>=g[q[tt-1]]+(k-q[tt-1])/v*w)--tt;
                q[tt]=k;
                ++tt;
            }
        }
    }
    cout<<f[m]<<endl;
    return 0;
}
```
## 期望DP
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=310+10;
typedef pair<int,int>pp;
int a[N],cnt[4];
double f[N][N][N];

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cout.setf(ios::fixed);
    cout.precision(9);
    int n;
    cin>>n;
    f[0][0][0]=0;
    for(int i=1;i<=n;++i)cin>>a[i],cnt[a[i]]++;
    for(int k=0;k<=n;++k){
        for(int j=0;j<=n;++j){
            for(int i=0;i<=n;++i){
                if(i||j||k){
                    int d=i+j+k;
                    if(i)f[i][j][k]+=f[i-1][j][k]*i/d;
                    if(j)f[i][j][k]+=f[i+1][j-1][k]*j/d;
                    if(k)f[i][j][k]+=f[i][j+1][k-1]*k/d;
                    f[i][j][k]+=1.0*n/d;
                }
            }
        }
    }
    cout<<f[cnt[1]][cnt[2]][cnt[3]]<<endl;

    return 0;
}
```
## 区间DP
```
/*https://www.luogu.com.cn/problem/P1775*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=310;
int a[N],s[N],f[N][N],p[N][N];
int n;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n;
    memset(f,0x3f,sizeof f);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        s[i]=s[i-1]+a[i];
        f[i][i]=0;
        p[i][i]=i;
    }
    for(int len=2;len<=n;++len){
        for(int i=1;i+len-1<=n;++i){
            int j=i+len-1;
            for(int k=p[i][j-1];k<=p[i+1][j];++k){
                if(f[i][j]>f[i][k]+f[k+1][j]+s[j]-s[i-1]){
                    f[i][j]=f[i][k]+f[k+1][j]+s[j]-s[i-1];
                    p[i][j]=k;
                }
            }
        }
    }
    cout<<f[1][n]<<endl;
    return 0;
}
```
## 树形DP
```
/*https://www.acwing.com/problem/content/description/287/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=6e3+10;
int a[N],f[N][2],vis[N];
int e[N<<1],ne[N<<1],h[N],idx;
void add(int a,int b){
    e[++idx]=b,ne[idx]=h[a],h[a]=idx;
}
void dfs(int u,int fa){
    f[u][0]=0,f[u][1]=a[u];
    for(int i=h[u];i!=-1;i=ne[i]){
        int v=e[i];
        if(v!=fa){
            dfs(v,u);
            f[u][0]+=max(f[v][0],f[v][1]);
            f[u][1]+=f[v][0];
        }
    }
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	memset(h,-1,sizeof h);
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<n;++i){
	    int l,k;
	    cin>>l>>k;
	    add(l,k);
	    add(k,l);
	}
	dfs(1,0);
	cout<<max(f[1][0],f[1][1])<<endl;
	return 0;
} 
```
## 数位DP
```
/*https://www.luogu.com.cn/problem/P2602*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
int a, b;
int f[15],ksm[15],p[15],now[15];

int dfs(int u, int x, bool f0,bool lim) {  // u 表示位数，f0 是否有前导零，lim 是否都贴在上限上
    if (!u) {
        if (f0) f0 = 0;
        return 0;
    }
    if (!lim && !f0 && (~f[u])) return f[u];
    int cnt = 0;
    int lst = lim ? p[u] : 9;
    for (int i = 0; i <= lst; i++) {  // 枚举这位要填的数字
        if (f0 && i == 0)
            cnt += dfs(u - 1, x, 1, lim && i == lst);  // 处理前导零
        else if (i == x && lim && i == lst)
            cnt += now[u - 1] + 1 +dfs(u - 1, x, 0,lim && i == lst);  // 此时枚举的前几位都贴在给定的上限上。
        else if (i == x)
            cnt += ksm[u - 1] + dfs(u - 1, x, 0, lim && i == lst);
        else
            cnt += dfs(u - 1, x, 0, lim && i == lst);
    }
    if ((!lim) && (!f0)) f[u] = cnt;  // 只有不贴着上限和没有前导零才能记忆
    return cnt;
}

int cal(int d, int dig) {
    int len = 0;
    memset(f, -1, sizeof(f));
    while (d) {
        p[++len] = d % 10;
        d /= 10;
        now[len] = now[len - 1] + p[len] * ksm[len - 1];
    }
    return dfs(len, dig, 1, 1);
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>a>>b;
    ksm[0] = 1;
    for (int i = 1; i <= 12; i++) ksm[i] = ksm[i - 1] * 10;
    for (int i = 0; i <= 9; i++) cout<<cal(b, i) - cal(a - 1, i)<<" \n"[i==9];
    return 0;
}
```
# 数据结构
## 可持久化
### 可持久化线段树
```
/*https://www.acwing.com/problem/content/257/*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
vector<int>num;

int n,m,idx;
const int N=1e5+10,M=1e4+10;
int a[N],root[N];
struct info{
    int cnt;
};
struct Node{
    int l,r;
    info val;
}node[N*4+17*N];
info operator+(const info &a,const info &b){
    return {a.cnt+b.cnt};
}
int find(int x){
    return lower_bound(num.begin(),num.end(),x)-num.begin();
}
int build(int l,int r){
    int p=++idx;
    if(l==r)return r;
    int mid=(l+r)>>1;
    node[p].l=build(l,mid);
    node[p].r=build(mid+1,r);
    return p;
}
void update(int p){
    node[p].val=node[node[p].l].val+node[node[p].r].val;
}
int insert(int p,int l,int r,int x){
    int q=++idx;
    node[q]=node[p];
    if(l==r){
        node[q].val.cnt++;
        return q;
    }
    int mid=(l+r)>>1;
    if(x<=mid)node[q].l=insert(node[q].l,l,mid,x);
    else node[q].r=insert(node[q].r,mid+1,r,x);
    update(q);
    return q;
}
int query(int q,int p,int l,int r,int k){
    if(l==r)return r;
    int cnt=node[node[q].l].val.cnt-node[node[p].l].val.cnt;
    int mid=(l+r)>>1;
    if(k<=cnt)return query(node[q].l,node[p].l,l,mid,k);
    else return query(node[q].r,node[p].r,mid+1,r,k-cnt);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        num.push_back(a[i]);
    }
    sort(num.begin(),num.end());
    num.erase(unique(num.begin(),num.end()),num.end());
    root[0]=build(0,num.size()-1);
    for(int i=1;i<=n;++i){
        root[i]=insert(root[i-1],0,num.size()-1,find(a[i]));
    }
    while(m--){
        int l,r,k;
        cin>>l>>r>>k;
        cout<<num[query(root[r],root[l-1],0,num.size()-1,k)]<<endl;
    }

    return 0;
}
```
### 可持久化Trie树
```
/*https://www.luogu.com.cn/problem/P4735*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 600010, M = N * 25;

int n, m;
int s[N];
int tr[M][2], max_id[M];
int root[N], idx;

void insert(int i, int k, int p, int q){
    if (k<0){
        max_id[q] = i;
        return;
    }
    int v = s[i]>>k&1;
    if (p)tr[q][v^1] = tr[p][v^1];
    tr[q][v] = ++idx;
    insert(i,k-1,tr[p][v],tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

int query(int root, int C, int L){
    int p = root;
    for (int i = 23; i >= 0; i -- ){
        int v = C>>i&1;
        if (max_id[tr[p][v ^ 1]]>=L) p = tr[p][v^1];
        else p = tr[p][v];
    }

    return C^s[max_id[p]];
}

int main()
{
    cin>>n>>m;

    max_id[0] = -1;
    root[0] = ++ idx;
    insert(0, 23, 0, root[0]);

    for (int i = 1; i <= n; i ++ ){
        int x;
        cin>>x;
        s[i] = s[i - 1] ^ x;
        root[i] = ++ idx;
        insert(i, 23, root[i - 1], root[i]);
    } 
    while (m -- ){
        char op;
        int l, r, x;
        cin>>op;
        if (op == 'A'){
            cin>>x;
            n++;
            s[n] = s[n-1]^x;
            root[n] = ++idx;
            insert(n,23,root[n-1],root[n]);
        }
        else{
            cin>>l>>r>>x;
            cout<<query(root[r - 1], s[n] ^ x, l - 1)<<endl;
        }
    }

    return 0;
}
```
## 树链剖分
### 区间修改
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
int w[N];
int n,m;
int h[N],e[N*4],ne[N*4],idx;
int sz[N],hs[N],fa[N],dep[N];
int l[N],r[N],top[N],idd[N],tot;
void add(int a,int b){
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}
struct info{
    int sum;
};
struct Node{
    info val;
    int size;
    int tag;
}node[N*4];
info operator+(const info &a,const info &b){
    return {a.sum+b.sum};
}
void settag(int id,int t){
    node[id].tag+=t;
    //cout<<id<<" "<<node[id].val.sum<<" "<<node[id].val.size<<endl;
    node[id].val.sum+=node[id].size*t;
    
}
void update(int id){
    node[id].val=node[id<<1].val+node[id<<1|1].val;
}
void pushdown(int id){
    if(node[id].tag){
        int t=node[id].tag;
        settag(id<<1,t);
        settag(id<<1|1,t);
        node[id].tag=0;
    }
}
void build(int id,int l,int r){
    node[id].size=r-l+1;
    if(l==r){
        node[id].val={w[idd[l]]};

    }else {
        int mid=l+r>>1;
        build(id<<1,l,mid);
        build(id<<1|1,mid+1,r);
        update(id);
    }
}
void modify(int id,int l,int r,int ql,int qr,int t){
    if(l==ql&&r==qr){
    	settag(id,t);
		return;	
	}
    //cout<<id<<" "<<l<<" "<<r<<" "<<ql<<" "<<qr<<endl;
    pushdown(id);
    int mid=l+r>>1;
    if(qr<=mid)modify(id<<1,l,mid,ql,qr,t);
    else if(ql>mid)modify(id<<1|1,mid+1,r,ql,qr,t);
    else {
        modify(id<<1,l,mid,ql,mid,t);
        modify(id<<1|1,mid+1,r,mid+1,qr,t);
    }
    update(id);
}
int query(int id,int l,int r,int ql,int qr){
    if(l==ql&&r==qr)return node[id].val.sum;
    else {
        pushdown(id);
        int mid=l+r>>1;
        if(qr<=mid)return query(id<<1,l,mid,ql,qr);
        else if(ql>mid)return query(id<<1|1,mid+1,r,ql,qr);
        else return query(id<<1,l,mid,ql,mid)+query(id<<1|1,mid+1,r,mid+1,qr);
    }
}
void dfs1(int u,int f){
    sz[u]=1;
    hs[u]=-1;
    fa[u]=f;
    dep[u]=dep[f]+1;
    for(int i=h[u];i!=-1;i=ne[i]){
        int v=e[i];
        if(v==f)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(hs[u]==-1||sz[v]>sz[hs[u]])hs[u]=v;
    }
}
void dfs2(int u,int t){
    top[u]=t;
    l[u]=++tot;
    //cout<<"u:"<<u<<" "<<l[u]<<endl;
    idd[tot]=u;
    if(hs[u]!=-1)dfs2(hs[u],t);
    for(int i=h[u];i!=-1;i=ne[i]){
        int v=e[i];
        if(v!=fa[u]&&v!=hs[u]){
            dfs2(v,v);
        }
    }
    r[u]=tot;
}
void mfy(int u,int v,int k){
    while(top[u]!=top[v]){
        if(dep[top[u]]>dep[top[v]])swap(u,v);
            //cout<<"mfy:"<<u<<" "<<top[u]<<" "<<v<<" "<<top[v]<<" "<<fa[top[v]]<<" "<<l[v]<<endl;
			modify(1,1,n,l[top[v]],l[v],k);
            //cout<<query(1,1,n,l[top[v]],l[v])<<endl;
            v=fa[top[v]];
            
    }
    if(dep[u]>dep[v])swap(u,v);
    modify(1,1,n,l[u],l[v],k);
}
int qry(int u,int v){
    int ans=0;    
    while(top[u]!=top[v]){
        if(dep[top[u]]>dep[top[v]])swap(u,v);
        //cout<<"qfy:"<<u<<" "<<top[u]<<" "<<v<<" "<<top[v]<<" "<<fa[top[v]]<<endl;
        ans+=query(1,1,n,l[top[v]],l[v]);
        v=fa[top[v]];
    }
    if(dep[u]>dep[v])swap(u,v);
    ans+=query(1,1,n,l[u],l[v]);
    return ans;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n;
    for(int i=0;i<=n+1;++i)h[i]=-1;
    for(int i=1;i<=n;++i)cin>>w[i];
    for(int i=1;i<n;++i){
        int u,v;
        cin>>u>>v;
        add(u,v);
        add(v,u);
    }
    dfs1(1,0);
    dfs2(1,0);
    build(1,1,n);
    cin>>m;
    while(m--){
        int op,u,v,k;
        cin>>op;
		//cout<<"op:"<<op<<endl;
        if(op==1){
            cin>>u>>v>>k;
            mfy(u,v,k);
        }else if(op==2){
            cin>>u>>k;
            modify(1,1,n,l[u],r[u],k);
        }else if(op==3){
            cin>>u>>v;
            cout<<qry(u,v)<<endl;
        }else {
            cin>>u;
            cout<<query(1,1,n,l[u],r[u])<<endl;
        }
        
    }
    
    return 0;
}
```
### 单点修改
```
/*http://oj.daimayuan.top/course/15/problem/819*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,q;
const int N=3e4+10,inf=1e9;
int w[N];
int e[N*2],nex[N*2],h[N],idx;
int l[N],r[N],idd[N],sz[N],hs[N],tot,top[N],dep[N],fa[N];
void add(int a,int b){
    e[++idx]=b,nex[idx]=h[a],h[a]=idx;
}
struct info{
    int maxv,sum;
};
struct Node{
    info val;
}node[N*4];
info operator+(const info &a,const info &b){
    return {max(a.maxv,b.maxv),a.sum+b.sum};
}
void update(int id){
    node[id].val=node[id*2].val+node[id*2+1].val;
}
void build(int id,int l,int r){
    if(l==r){
        node[id].val={w[idd[l]],w[idd[l]]};
    }else{
        int mid=(l+r)>>1;
        build(id*2,l,mid);
        build(id*2+1,mid+1,r);
        update(id);
    }
}
void change(int id,int l,int r,int pos,int val){
    if(l==r){
        node[id].val={val,val};
    }else {
        int mid=(l+r)>>1;
        if(pos<=mid)change(id*2,l,mid,pos,val);
        else change(id*2+1,mid+1,r,pos,val);
        update(id);
    }
}
info query(int id,int l,int r,int ql,int qr){
    if(l==ql&&r==qr){
        return node[id].val;
    }else {
        int mid=(l+r)>>1;
        if(qr<=mid)return query(id*2,l,mid,ql,qr);
        else if(ql>mid)return query(id*2+1,mid+1,r,ql,qr);
        else {
            return query(id*2,l,mid,ql,mid)+query(id*2+1,mid+1,r,mid+1,qr);
        }
    }
}
//第一遍DFS，子树大小，重儿子，父亲，深度
void dfs1(int u,int f){
    sz[u]=1;
    hs[u]=-1;
    fa[u]=f;
    dep[u]=dep[f]+1;
    for(int i=h[u];i!=-1;i=nex[i]){
        int v=e[i];
        if(v==f)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(hs[u]==-1||sz[v]>sz[hs[u]])hs[u]=v;
    }
}
//第二遍DFS，每个点的DFS序，重链上的链头元素
void dfs2(int u,int t){
    top[u]=t;
    l[u]=++tot;
    idd[tot]=u;
    if(hs[u]!=-1){
        dfs2(hs[u],t);
    }
    for(int i=h[u];i!=-1;i=nex[i]){
        int v=e[i];
        if(v!=fa[u] &&v!=hs[u]){
            dfs2(v,v);
        }
    }
    r[u]=tot;
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])v=fa[top[v]];
		else u=fa[top[u]];
	}
	if(dep[u]<dep[v])return u;
	else return v;
} 
info qry(int u,int v){
    info ans=(info){-inf,0};
    //cout<<"OK "<<u<<" "<<v<<" "<<top[u]<<" "<<top[v]<<" "<<endl;
    while(top[u]!=top[v]){
		//cout<<"OK "<<u<<" "<<v<<" "<<top[u]<<" "<<top[v]<<" "<<fa[top[u]]<<" "<<fa[top[v]]<<" "<<fa[top[u]]<<" "<<dep[top[u]]<<" "<<dep[top[v]]<<endl;
        if(dep[top[u]]<dep[top[v]]){
            ans=ans+query(1,1,n,l[top[v]],l[v]);
            v=fa[top[v]];
        }else {
            ans=ans+query(1,1,n,l[top[u]],l[u]);
            u=fa[top[u]];
        }
        //cout<<"dddddd"<<u<<" "<<v<<" "<<ans.maxv<<" "<<ans.sum<<endl;
    }
    if(dep[u]<=dep[v])ans=ans+query(1,1,n,l[u],l[v]);
    else ans=ans+query(1,1,n,l[v],l[u]);
    //cout<<"+++++"<<ans.maxv<<" "<<ans.sum<<endl;
    return ans;
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    cin>>n;
    memset(h,-1,sizeof h);
    for(int i=1;i<n;++i){
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    for(int i=1;i<=n;++i)cin>>w[i];
	dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    cin>>q;
    while(q--){
        int u,v;
        string opt;
        cin>>opt>>u>>v;
        if(opt[0]=='C')change(1,1,n,l[u],v);
        else {
            info ans=qry(u,v);
			if(opt[1]=='M')cout<<ans.maxv<<endl;
			else cout<<ans.sum<<endl; 
        }
    }
	return 0;
} 
```
## 树套树
### 线段树套Splay
```
/*https://www.luogu.com.cn/problem/P3380*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N=50005,INF=2147483647;
#define ls(x) tr[x].s[0]
#define rs(x) tr[x].s[1]
struct node{
    int s[2], p;
    int v, siz;
    void init(int p1, int v1){
        p=p1; v=v1; siz=1;
    }
}tr[N*40];
int n, m, w[N], idx;

inline void pushup(int x){
    tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+1;
}
inline void rotate(int x){
    int y=tr[x].p,z=tr[y].p;
    int k=tr[y].s[1]==x;
    tr[z].s[tr[z].s[1]==y]=x, tr[x].p=z;
    tr[y].s[k]=tr[x].s[k^1], tr[tr[x].s[k^1]].p=y;
    tr[x].s[k^1]=y, tr[y].p=x;
    pushup(y), pushup(x);
}
inline void splay(int &root,int x,int k){
    while(tr[x].p != k){
        int y=tr[x].p,z=tr[y].p;
        if(z != k)
        if((rs(y)==x)^(rs(z)==y)) rotate(x);
        else rotate(y);
        rotate(x);
    }
    if(!k) root=x;
}
inline void insert(int &root,int v){
    int u=root,p=0;
    while(u) p=u,u=tr[u].s[v>tr[u].v];
    u = ++idx;
    tr[p].s[v>tr[p].v]=u;
    tr[u].init(p,v);
    splay(root,u,0);
}
inline void del(int &root,int v){
    int u=root;
    while(u){
        if(tr[u].v==v) break;
        if(tr[u].v<v) u=rs(u);
        else u=ls(u);
    }
    splay(root,u,0);
    int l=ls(u),r=rs(u);
    while(rs(l)) l=rs(l);
    while(ls(r)) r=ls(r);
    splay(root,l,0);
    splay(root,r,l);
    ls(r)=0;
    splay(root,r,0);
}
inline int getrank(int root,int v){
    int u=root,res=0;
    while(u){
        if(tr[u].v<v) 
        res+=tr[ls(u)].siz+1,u=rs(u);
        else u=ls(u);
    }
    return res;
}
inline int getpre(int root,int v){
    int u=root,res=-INF;
    while(u){
        if(tr[u].v<v) 
        res=tr[u].v,u=rs(u);
        else u=ls(u);
    }
    return res;
}
inline int getnxt(int root,int v){
    int u=root,res=INF;
    while(u){
        if(tr[u].v>v) 
        res=tr[u].v,u=ls(u);
        else u=rs(u);
    }
    return res;
}

//////////线段树
#define lc u<<1
#define rc u<<1|1
int root[N*4];

void build(int u,int l,int r){
    insert(root[u],-INF), insert(root[u],INF);
    for(int i=l;i<=r;i++)insert(root[u],w[i]);
    if(l==r) return;
    int mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
}
int queryrank(int u,int l,int r,int x,int y,int v){
    if(x<=l && r<=y) return getrank(root[u],v)-1;
    int mid=l+r>>1, res=0;
    if(x<=mid) res += queryrank(lc,l,mid,x,y,v);
    if(y>mid) res += queryrank(rc,mid+1,r,x,y,v);
    return res;
}
int queryval(int u,int x,int y,int k){
    int l=0, r=1e8, ans; //二分
    while(l<=r){
        int mid=l+r>>1;
        if(queryrank(1,1,n,x,y,mid)+1<=k) 
        l=mid+1, ans=mid;
        else r=mid-1;
    }
    return ans;
}
void change(int u,int l,int r,int pos,int v){
    del(root[u],w[pos]);
    insert(root[u],v);
    if(l==r) return;
    int mid=l+r>>1;
    if(pos<=mid) change(lc,l,mid,pos,v);
    else change(rc,mid+1,r,pos,v);
}
int querypre(int u,int l,int r,int x,int y,int v){
    if(x<=l && r<=y) return getpre(root[u],v);
    int mid=l+r>>1, res=-INF;
    if(x<=mid) res=max(res,querypre(lc,l,mid,x,y,v));
    if(y>mid) res=max(res,querypre(rc,mid+1,r,x,y,v));
    return res;
}
int querynxt(int u,int l,int r,int x,int y,int v){
    if(x<=l && r<=y) return getnxt(root[u],v);
    int mid=l+r>>1, res=INF;
    if(x<=mid) res=min(res,querynxt(lc,l,mid,x,y,v));
    if(y>mid) res=min(res,querynxt(rc,mid+1,r,x,y,v));
    return res;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>w[i];
    build(1,1,n);
    while(m -- ){
        int op,x,y,v;
        cin>>op;
        if(op==3)cin>>x>>v;
        else cin>>x>>y>>v;
        if(op==1)
            cout<<queryrank(1,1,n,x,y,v)+1<<endl;
        if(op==2) 
            cout<<queryval(1,x,y,v)<<endl;
        if(op==3)
            change(1,1,n,x,v), w[x]=v;
        if(op==4)
            cout<<querypre(1,1,n,x,y,v)<<endl;
        if(op==5)
            cout<<querynxt(1,1,n,x,y,v)<<endl;
    }
    return 0;
}
```
### 线段树套STL
```
/*https://www.acwing.com/problem/content/description/2490/*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N=5e4+10,INF=1e9;
int a[N];
int n,m;
struct Node{
    multiset<int>s;
}node[N*4];
void build(int id,int l,int r){
    node[id].s.insert(INF),node[id].s.insert(-INF);
    for(int i=l;i<=r;++i)node[id].s.insert(a[i]);
    if(l==r)return;
    else {
        int mid=l+r>>1;
        build(id<<1,l,mid);
        build(id<<1|1,mid+1,r);
    }
}
void change(int id,int l,int r,int pos,int d){
    node[id].s.erase(node[id].s.find(a[pos]));
    node[id].s.insert(d);
    if(l==r)return;
    else {
        int mid=l+r>>1;
        if(pos<=mid)change(id<<1,l,mid,pos,d);
        else change(id<<1|1,mid+1,r,pos,d);
        
    }
}
int query(int id,int l,int r,int ql,int qr,int x){
    if(l==ql&&r==qr){
        auto it=node[id].s.lower_bound(x);
        --it;
        return *it;
    }
    int mid=l+r>>1;
    int res=-INF;
    if(qr<=mid)return query(id<<1,l,mid,ql,qr,x);
    else if(ql>mid)return query(id<<1|1,mid+1,r,ql,qr,x);
    else return max(query(id<<1,l,mid,ql,mid,x),query(id<<1|1,mid+1,r,mid+1,qr,x));
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    build(1,1,n);
    while(m--){
        int op,aa,b,x;
        cin>>op;
        if(op==1){
            cin>>aa>>x;
            change(1,1,n,aa,x);
            a[aa]=x;
        }else {
            cin>>aa>>b>>x;
            cout<<query(1,1,n,aa,b,x)<<endl;
        }
    }

    return 0;
}
```
## 树状数组
### 二维数点
```
/*http://oj.daimayuan.top/course/15/problem/686*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,q;
const int N=2e5+10;
int c[N],a[N],ans[N];
vector<array<int,4> >event;
vector<int>vx; 
void modify(int x,int d){
	for(;x<=n;x+=x&(-x)){
		c[x]+=d;
	}
}
int query(int x){
	int sum=0;
	for(;x;x-=x&(-x)){
		sum+=c[x];
	}
	return sum;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		int x,y;
		cin>>x>>y;
		event.push_back({y,0,x});
		vx.push_back(x);
	}
	for(int i=1;i<=q;++i){
		int X1,Y1,X2,Y2;
		cin>>X1>>X2>>Y1>>Y2;
		event.push_back({Y2,2,X2,i});
		event.push_back({Y1-1,2,X1-1,i});
		event.push_back({Y1-1,1,X2,i});
		event.push_back({Y2,1,X1-1,i});
	}
	sort(event.begin(),event.end());
	sort(vx.begin(),vx.end());
	vx.erase(unique(vx.begin(),vx.end()),vx.end());
	for(auto &evt:event){
		if(evt[1]==0){
			int y=lower_bound(vx.begin(),vx.end(),evt[2])-vx.begin()+1;
			modify(y,1);
		}else {
			int y=upper_bound(vx.begin(),vx.end(),evt[2])-vx.begin();
			//int y2=lower_bound(vx.begin(),vx.end(),evt[2])-vx.begin()+1;
			//printf("%d %d %d %d\n",y,y2,evt[2],vx[0]);
			if(evt[1]==1){
				ans[evt[3]]-=query(y);
			}else ans[evt[3]]+=query(y);
		}
	}
	for(int i=1;i<=n;++i){
		cout<<ans[i]<<endl;
	}
	return 0;
} 
```
### 树状数组
```
/*http://oj.daimayuan.top/course/15/problem/634*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=2e5+10;
int a[N],c[N]; 
int n,q;
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;

    Fenwick(int n) : n(n), tr(n + 1, 0){}

    int lowbit(int x){
        return x & -x;
    }

    void modify(int x, T c){
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }

    void modify(int l, int r, T c){
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }

    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }

    T query(int l, int r){
        return query(r) - query(l - 1);
    }

    int find_first(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans + 1;
    }

    int find_last(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans;
    }

};
using BIT = Fenwick<int>;
void modify(int x,int d){
	for(;x<=n;x+=x&(-x)){
		c[x]+=d;
	}
}
int query(int x){
	int sum=0;
	for(;x;x-=x&(-x)){
		sum+=c[x];
	}
	return sum;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		modify(i,a[i]);
	}
	while(q--){
		int opt;
		cin>>opt;
		if(opt==1){
			int x,d;
			cin>>x>>d;
			modify(x,d-a[x]);
			a[x]=d;
		}else {
			int x;
			cin>>x;
			cout<<query(x)<<endl;
		}
	}
	return 0;
} 
```
### 树状数组求逆序对
```
/*http://oj.daimayuan.top/course/15/problem/653*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n;
const int N=1e5+10;
int a[N],c[N];
void modify(int x,int d){
	for(;x<=n;x+=(-x)&x){
		c[x]+=d;
	}
}
int query(int x){
	int sum=0;
	for(;x;x-=x&(-x)){
		sum+=c[x];
	}
	return sum;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		a[i]=n-a[i]+1;
		
	}
	int sum=0;
	for(int i=1;i<=n;++i){
		sum+=query(a[i]);
		modify(a[i],1);
	}
	cout<<sum<<endl;
	return 0;
} 
```
## 线段树
### 单点修改
```
/*http://oj.daimayuan.top/course/15/problem/658*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,q;
const int N=2e5+10;
int a[N];
struct info{
	int ans,s,ps,bs;
}; 
struct Node{
	info val;
}node[N*4];
info operator +(const info &a,const info &b){
	info res;
	res.ans=max({a.ans,b.ans,a.bs+b.ps});
	res.ps=max(a.ps,a.s+b.ps);
	res.bs=max(b.bs,a.bs+b.s);
	res.s=a.s+b.s;
	return res;
}
void update(int id){
	node[id].val=node[id*2].val+node[id*2+1].val;
}
void build(int id,int l,int r){
	if(l==r){
		node[id]={a[l],a[l],a[l],a[l]};
	}else {
		int mid=(l+r)>>1;
		build(id*2,l,mid);
		build(id*2+1,mid+1,r);
		update(id);
	}
}
void change(int id,int l,int r,int pos,int d){
	if(l==r){
		node[id].val={d,d,d,d};
	}else {
		int mid=(l+r)>>1;
		if(pos<=mid)change(id*2,l,mid,pos,d);
		else change(id*2+1,mid+1,r,pos,d);
		update(id);
	}
}
info query(int id,int l,int r,int ql,int qr){
	if(l==ql&&r==qr){
		return node[id].val;
	}
	int mid=(l+r)>>1;
	if(qr<=mid)return query(id*2,l,mid,ql,qr);
	else if(ql>mid)return query(id*2+1,mid+1,r,ql,qr);
	else return query(id*2,l,mid,ql,mid)+query(id*2+1,mid+1,r,mid+1,qr);
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>q;
	for(int i=1;i<=n;++i)cin>>a[i];
	build(1,1,n);
	while(q--){
		int opt;
		cin>>opt;
		if(opt==1){
			int x,d;
			cin>>x>>d;
			change(1,1,n,x,d);
		}else {
			int l,r;
			cin>>l>>r;
			auto res=query(1,1,n,l,r);
			cout<<res.ans<<endl;
		}
	}
	
	return 0;
} 
```
### 区间修改
```
/*http://oj.daimayuan.top/course/15/problem/660*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,q;
const int N=2e5+10,mod=1e9+7;
int a[N];
struct info{
	int sum;
};
struct tag{
	int mul,add;
};
struct Node{
	info val;
    int sz;
	tag t;
}node[N*4];
info operator+(const info &a,const info &b){
	return {(a.sum+b.sum)%mod};
}
tag operator+(const tag &a,const tag &b){
	return {a.mul*b.mul%mod,(a.add*b.mul+b.add)%mod};	
}
void settag(int id,tag t){
	node[id].t=node[id].t+t;
	node[id].val.sum=(node[id].val.sum*t.mul+node[id].sz*t.add)%mod;
}
void update(int id){
	node[id].val=node[id*2].val+node[id*2+1].val;
}
void pushdown(int id){
	if(node[id].t.mul!=1||node[id].t.add!=0){
		settag(id*2,node[id].t);
		settag(id*2+1,node[id].t);
		node[id].t={1,0};
	}
}
void build(int id,int l,int r){
	node[id].sz=r-l+1;
	node[id].t={1,0};
	if(l==r)node[id].val.sum=a[l];
	else {
		int mid=(l+r)>>1;
		build(id*2,l,mid);
		build(id*2+1,mid+1,r);
		update(id);
	}
}
void modify(int id,int l,int r,int ql,int qr,tag t){
	if(l==ql&&r==qr){
		settag(id,t);
		return;
	}
	pushdown(id);
	int mid=(l+r)>>1;
	if(qr<=mid)modify(id*2,l,mid,ql,qr,t);
	else if(ql>mid)modify(id*2+1,mid+1,r,ql,qr,t);
	else {
		modify(id*2,l,mid,ql,mid,t);
		modify(id*2+1,mid+1,r,mid+1,qr,t);
	}
	update(id);
}
info query(int id,int l,int r,int ql,int qr){
	if(ql==l&&qr==r){
		return node[id].val;
	}
	pushdown(id);
	int mid=(l+r)>>1;
	if(qr<=mid)return query(id*2,l,mid,ql,qr);
	else if(ql>mid)return query(id*2+1,mid+1,r,ql,qr);
	else {
		return query(id*2,l,mid,ql,mid)+query(id*2+1,mid+1,r,mid+1,qr);
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	build(1,1,n);
	while(q--){
		int opt;
		cin>>opt;
		if(opt==1){
			int l,r,d;
			cin>>l>>r>>d;
			modify(1,1,n,l,r,tag{1,d});
		}else if(opt==2){
			int l,r,d;
			cin>>l>>r>>d;
			modify(1,1,n,l,r,tag{d,0}); 
		}else if(opt==3){
			int l,r,d;
			cin>>l>>r>>d;
			modify(1,1,n,l,r,tag{0,d});
		}else {
			int l,r;
			cin>>l>>r;
			auto res=query(1,1,n,l,r);
			cout<<res.sum<<endl;
		}
	}
	
	return 0;
} 
```
### 线段树合并
```
/*https://www.luogu.com.cn/problem/P4556*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N=1e5+10;
typedef pair<int,int>pp;
int a[N];
int e[N*2],h[N],ne[N*2],idx;
int fa[N][20],dep[N];
int root[N];
int ans[N];
int tot;
struct info{
    int sum,res;
};
struct Node{
    int l,r;
    info val;
}node[N*50];
info operator+(const info &a,const info &b){
    if(a.sum<b.sum)return {b.sum,b.res};
    else return{a.sum,a.res};
}
void add(int a,int b){
    e[++idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
}
queue<int>q;
void bfs(int rt){
    memset(dep,0x3f,sizeof dep);
    dep[0]=0,dep[rt]=1;
    q.push(rt);
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=h[u];~i;i=ne[i]){
            int j=e[i];
            if(dep[j]>dep[u]+1){
                dep[j]=dep[u]+1;
                q.push(j);
                fa[j][0]=u;
                for(int k=1;k<=17;++k){
                    fa[j][k]=fa[fa[j][k-1]][k-1];
                }
            }
        }
    }
}
int lca(int a,int b){
    if(dep[a]<dep[b])swap(a,b);
    for(int k=17;k>=0;--k){
        if(dep[fa[a][k]]>=dep[b])
            a=fa[a][k];
    }
    if(a==b)return a;
    for(int k=17;k>=0;--k){
        if(fa[a][k]!=fa[b][k]){
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
void update(int id){
    node[id].val=node[node[id].l].val+node[node[id].r].val;
}
int insert(int id,int l,int r,int pos,int val){
    if(!id)id=++tot;
    if(l==r){
        node[id].val.sum+=val;
        node[id].val.res=pos;
        return id;
    }
    int mid=l+r>>1;
    if(pos<=mid)node[id].l=insert(node[id].l,l,mid,pos,val);
    else node[id].r=insert(node[id].r,mid+1,r,pos,val);
    update(id);
    return id;
}
int merge(int p, int q, int l, int r) {
    if (!p) return q;
    if (!q) return p;
    if (l == r) {
        node[p].val.sum += node[q].val.sum;
        return p;
    }
    int mid = (l + r) >> 1;
    node[p].l = merge(node[p].l, node[q].l, l, mid);
    node[p].r = merge(node[p].r, node[q].r, mid + 1, r);
    update(p);
    return p;
}
void cal(int u){
    for(int i=h[u];~i;i=ne[i]){
        int v=e[i];
        if(v==fa[u][0])continue;
        cal(v);
        root[u]=merge(root[u],root[v],1,N);
    }
    ans[u]=node[root[u]].val.res;
    if(node[root[u]].val.sum==0)ans[u]=0;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,m;
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<n;++i){
        int a,b;
        cin>>a>>b;
        add(a,b),add(b,a);
    }
    bfs(1);
    for(int i=1;i<=m;++i){
        int a,b,c;
        cin>>a>>b>>c;
        root[a]=insert(root[a],1,N,c,1);
        root[b]=insert(root[b],1,N,c,1);
        int t=lca(a,b);
        root[t]=insert(root[t],1,N,c,-1);
        root[fa[t][0]]=insert(root[fa[t][0]],1,N,c,-1);
    }
    cal(1);
    for(int i=1;i<=n;++i)cout<<ans[i]<<endl;

    return 0;
}
```
### 线段树建图
```
/*https://www.luogu.com.cn/problem/CF786B*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10,M=N*30,D=N*5;
typedef pair<int,int>pp;
int a[M];
int h[M],e[M],ne[M],w[M],idx;
void add(int a,int b,int c){
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}
void build(int id,int l,int r){
	if(l==r){
		a[l]=id;
	}else {
		int mid=(l+r)>>1;
        add(id,id*2,0);
        add(id,id*2+1,0);
        add(id*2+D,id+D,0);
        add(id*2+1+D,id+D,0);
		build(id*2,l,mid);
		build(id*2+1,mid+1,r);
	}
}
void modify(int id,int l,int r,int ql,int qr,int v,int w,int op){
    if(l==ql&&r==qr){
		if(op)add(id+D,v,w);
        else add(v+D,id,w);
		return;
	}
	int mid=(l+r)>>1;
	if(qr<=mid)modify(id*2,l,mid,ql,qr,v,w,op);
	else if(ql>mid)modify(id*2+1,mid+1,r,ql,qr,v,w,op);
	else {
		modify(id*2,l,mid,ql,mid,v,w,op);
		modify(id*2+1,mid+1,r,mid+1,qr,v,w,op);
	}
}
int dis[M],vis[M];
priority_queue<pp,vector<pp>,greater<pp> > q;
void dijk(int s){
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    q.push(pp(0,s));
    while(!q.empty()){
        //cout<<dis[n]<<endl;
        int w1=q.top().first,u=q.top().second;
        //cout<<u<<" "<<w1<<endl;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(int i=h[u];i!=-1;i=ne[i]){
            int v=e[i];
            if(dis[v]>w1+w[i]){
                dis[v]=w1+w[i];
                q.push(pp(dis[v],v));
            }
        }
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,qq,s;
    cin>>n>>qq>>s;
    memset(h,-1,sizeof h);
    build(1,1,n);
    for(int i=1;i<=n;++i){
        add(a[i],a[i]+D,0);
        add(a[i]+D,a[i],0);
    }
    for(int i=1;i<=qq;++i){
        int opt;
        cin>>opt;
        if(opt==1){
            int v,u,w;
            cin>>v>>u>>w;
            add(a[v]+D,a[u],w);
        }else {
            int v,l,r,w;
            cin>>v>>l>>r>>w;
            modify(1,1,n,l,r,a[v],w,opt%2);
        }
    }
    dijk(a[s]+D);
    for(int i=1;i<=n;++i){
        if(dis[a[i]]==0x3f3f3f3f3f3f3f3f)cout<<-1<<" ";
        else cout<<dis[a[i]]<<" ";
    }
    cout<<endl;
    
    return 0;
}
```
### 线段树哈希
```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef unsigned long long int64;
const int N=2e5+10,D=200003;
typedef pair<int,int>pp;
int a[N],b[N],pos[N];
int64 d[N];
struct info{
	int res;
    int64 num;
}; 
struct Node{
	info val;
}node[N*4];
info operator +(const info &a,const info &b){
	info temp;
    temp.res=a.res+b.res;
    temp.num=a.num*d[b.res]+b.num;
    return temp;
}
void update(int id){
	node[id].val=node[id*2].val+node[id*2+1].val;
}
void change(int id,int l,int r,int pos,int dd){
	if(l==r){
		node[id].val={dd?node[id].val.res+1:node[id].val.res-1,(int64)dd};
	}else {
		int mid=(l+r)>>1;
		if(pos<=mid)change(id*2,l,mid,pos,dd);
		else change(id*2+1,mid+1,r,pos,dd);
		update(id);
	}
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,m;
    cin>>n>>m;
    int64 sum=0,aa=0;
    d[0]=1;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        sum=sum*D+a[i];
        d[i]=d[i-1]*D;
        aa+=d[i-1];
    }
    for(int i=1;i<=m;++i){
        cin>>b[i];
        pos[b[i]]=i;
    }
    int cnt=0;
    for(int i=1;i<=m;++i){
        if(i>n)change(1,1,m,pos[i-n],0);
        change(1,1,m,pos[i],i);
        if(i>=n&&node[1].val.num==(i-n)*aa+sum)
            ++cnt;
    }
    cout<<cnt<<endl;
    return 0;
}
```
## 并查集
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
typedef pair<int,int>pp;
struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    int size(int x) {
        return siz[find(x)];
    }
};
int a[N];
void solve()
{
    int n;
    cin>>n;
    DSU dsu(n+1);
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin>>T;
    while(T--)	solve();
    return 0;
}
```
## 带权并查集
```
/*http://oj.daimayuan.top/course/15/problem/719*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,q;
const int N=2e5+10;
int fa[N],w[N];
int find(int x){
	if(x==fa[x])return x;
	int p=fa[x];
	find(p);
	w[x]=w[x]+w[p];
	return fa[x]=fa[p];
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>q;
	int t=0;
	for(int i=1;i<=n;++i){
		fa[i]=i;
		w[i]=0;
	}
	for(int i=1;i<=q;++i){
		int opt,l,r;
		cin>>opt>>l>>r;
		int ql=(l+t)%n+1,qr=(r+t)%n+1;
		
		if(opt==1){
			int x;
			cin>>x;
			if(find(ql)==find(qr))continue;
			w[fa[ql]]=x-w[ql]+w[qr];
			fa[fa[ql]]=fa[qr]; 
		}else {
			if(find(ql)!=find(qr))continue;
			cout<<w[ql]-w[qr]<<endl;
			t=abs(w[ql]-w[qr]);
		}
	}
	
	return 0;
} 
```
## 单调队列
```
/*https://www.luogu.com.cn/problem/P1886*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e6+10;
int a[N],q1[N],q2[N];
int n,k;
vector<int>res1,res2;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>k;
    for(int i=1;i<=n;++i)cin>>a[i];
    int hh=0,tt=0;
    for(int i=1;i<=n;++i){
        while(hh<tt&&q1[hh]+k<=i){
            ++hh;
        }
        while(hh<tt&&a[q1[tt-1]]<a[i]){
            tt--;
        }
        q1[tt]=i;
        ++tt;
        if(i>=k)res1.push_back(a[q1[hh]]);
    }
    hh=0,tt=0;
    for(int i=1;i<=n;++i){
        while(hh<tt&&q2[hh]+k<=i){
            ++hh;
        }
        while(hh<tt&&a[q2[tt-1]]>a[i]){
            tt--;
        }
        q2[tt]=i;
        ++tt;
        if(i>=k)res2.push_back(a[q2[hh]]);
    }
    for(auto &x:res2){
        cout<<x<<" ";
    }
    cout<<endl;
    for(auto &x:res1){
        cout<<x<<" ";
    }
    cout<<endl;
    return 0;
}
```
## 单调栈
```
/*https://www.luogu.com.cn/problem/P5788*/
#include<bits/stdc++.h>//STL版
#define int long long
using namespace std;
#define endl '\n'
const int N=3e6+10;
int n;
int a[N],f[N];
stack<int>stk;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=n;i>=1;i--)
	{
		while(!stk.empty()&&a[stk.top()]<=a[i]) stk.pop();
		f[i]=stk.empty()?0:stk.top();
		stk.push(i);
	}
    for(int i=1;i<=n;++i)cout<<f[i]<<" ";
    cout<<endl;
    return 0;
}
/*#include<bits/stdc++.h>//数组版
#define int long long
using namespace std;
#define endl '\n'
const int N=3e6+10;
int n;
int a[N],f[N],hh;
int stk[N];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=n;i>=1;i--)
	{
		while(hh>0&&a[stk[hh]]<=a[i]) hh--;
		f[i]=hh?stk[hh]:0;
		stk[++hh]=i;
	}
    for(int i=1;i<=n;++i)cout<<f[i]<<" ";
    cout<<endl;
    return 0;
}*/
```
## 矩形面积并
```
/*https://www.luogu.com.cn/problem/P5788*/
#include<bits/stdc++.h>//STL版
#define int long long
using namespace std;
#define endl '\n'
const int N=3e6+10;
int n;
int a[N],f[N];
stack<int>stk;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=n;i>=1;i--)
	{
		while(!stk.empty()&&a[stk.top()]<=a[i]) stk.pop();
		f[i]=stk.empty()?0:stk.top();
		stk.push(i);
	}
    for(int i=1;i<=n;++i)cout<<f[i]<<" ";
    cout<<endl;
    return 0;
}
/*#include<bits/stdc++.h>//数组版
#define int long long
using namespace std;
#define endl '\n'
const int N=3e6+10;
int n;
int a[N],f[N],hh;
int stk[N];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    for(int i=n;i>=1;i--)
	{
		while(hh>0&&a[stk[hh]]<=a[i]) hh--;
		f[i]=hh?stk[hh]:0;
		stk[++hh]=i;
	}
    for(int i=1;i<=n;++i)cout<<f[i]<<" ";
    cout<<endl;
    return 0;
}*/
```
## 块状链表
```
/*https://www.acwing.com/activity/content/code/content/489888/*/
#include<bits/stdc++.h>
using namespace std;

const int N = 2000, M = 2010;

int n, x, y;
struct Node{
    char s[N + 1];
    int c, l, r;
}p[M];
char str[2000010];
int q[M], tt;  // 内存回收

void move(int k){  // 移到第k个字符后面
    x = p[0].r;
    while (k > p[x].c) k -= p[x].c, x = p[x].r;
    y = k - 1;
}

void add(int x, int u){  // 将节点u插到节点x的右边
    p[u].r = p[x].r, p[p[u].r].l = u;
    p[x].r = u, p[u].l = x;
}

void del(int u)  {// 删除节点u
    p[p[u].l].r = p[u].r;
    p[p[u].r].l = p[u].l;
    p[u].l = p[u].r = p[u].c = 0;  // 清空节点u
    q[ ++ tt] = u;  // 回收节点u
}

void insert(int k) { // 在光标后插入k个字符
    if (y < p[x].c - 1){  // 从光标处分裂
        int u = q[tt -- ];  // 新建一个节点
        for (int i = y + 1; i < p[x].c; i ++ )
            p[u].s[p[u].c ++ ] = p[x].s[i];
        p[x].c = y + 1;
        add(x, u);
    }
    int cur = x;
    for (int i = 0; i < k;){
        int u = q[tt -- ];  // 创建一个新的块
        while (p[u].c < N && i < k)
            p[u].s[p[u].c ++ ] = str[i ++ ];
        add(cur, u);
        cur = u;
    }
}

void remove(int k) { // 删除光标后的k个字符
    if (p[x].c - 1 - y >= k) { // 节点内删
        for (int i = y + k + 1, j = y + 1; i < p[x].c; i ++, j ++ ) p[x].s[j] = p[x].s[i];
        p[x].c -= k;
    }
    else{
        k -= p[x].c - y - 1;  // 删除当前节点的剩余部分
        p[x].c = y + 1;
        while (p[x].r && k >= p[p[x].r].c){
            int u = p[x].r;
            k -= p[u].c;
            del(u);
        }
        int u = p[x].r;  // 删除结尾节点的前半部分
        for (int i = 0, j = k; j < p[u].c; i ++, j ++ ) p[u].s[i] = p[u].s[j];
        p[u].c -= k;
    }
}

void get(int k){  // 返回从光标开始的k个字符
    if (p[x].c - 1 - y >= k) { // 节点内返回
        for (int i = 0, j = y + 1; i < k; i ++, j ++ ) putchar(p[x].s[j]);
    }
    else{
        k -= p[x].c - y - 1;
        for (int i = y + 1; i < p[x].c; i ++ ) putchar(p[x].s[i]);  // 输出当前节点的剩余部分
        int cur = x;
        while (p[cur].r && k >= p[p[cur].r].c){
            int u = p[cur].r;
            for (int i = 0; i < p[u].c; i ++ ) putchar(p[u].s[i]);
            k -= p[u].c;
            cur = u;
        }
        int u = p[cur].r;
        for (int i = 0; i < k; i ++ ) putchar(p[u].s[i]);
    }
    puts("");
}

void prev(){  // 光标向前移动一位

    if (!y){
        x = p[x].l;
        y = p[x].c - 1;
    }
    else y -- ;
}

void next(){  // 光标向后移动一位

    if (y < p[x].c - 1) y ++ ;
    else{
        x = p[x].r;
        y = 0;
    }
}

void merge(){  // 将长度较短的相邻节点合并，保证块状链表时间复杂度的核心
    for (int i = p[0].r; i; i = p[i].r){
        while (p[i].r && p[i].c + p[p[i].r].c < N){
            int r = p[i].r;
            for (int j = p[i].c, k = 0; k < p[r].c; j ++, k ++ )
                p[i].s[j] = p[r].s[k];
            if (x == r) x = i, y += p[i].c;  // 更新光标的位置
            p[i].c += p[r].c;
            del(r);
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    for (int i = 1; i < M; i ++ ) q[ ++ tt] = i;
    scanf("%d", &n);
    char op[10];

    str[0] = '>';
    insert(1);  // 插入哨兵
    move(1);  // 将光标移动到哨兵后面

    while (n -- ){
        int a;
        scanf("%s", op);
        if (!strcmp(op, "Move")){
            scanf("%d", &a);
            move(a + 1);
        }
        else if (!strcmp(op, "Insert")){
            scanf("%d", &a);
            int i = 0, k = a;
            while (a){
                str[i] = getchar();
                if (str[i] >= 32 && str[i] <= 126) i ++, a -- ;
            }
            insert(k);
            merge();
        }
        else if (!strcmp(op, "Delete")){
            scanf("%d", &a);
            remove(a);
            merge();
        }
        else if (!strcmp(op, "Get")){
            scanf("%d", &a);
            get(a);
        }
        else if (!strcmp(op, "Prev")) prev();
        else next();
    }

    return 0;
}
```
## 莫队
```
/*http://oj.daimayuan.top/course/15/problem/768*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
//#define endl '\n'
const int N=5e4+10,B=500;
int n,m;
int a[N];
int tmp;
int cnt[N],ans[N],bot[N];
array<int,3>que[N];
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
bool cmp(array<int,3>a,array<int,3>b){
    int C=a[0]/B;
    if(C!=b[0]/B)return C<b[0]/B;
    return C%2?a[1]>b[1]:a[1]<b[1];
}
void add(int x){
    tmp+=cnt[a[x]];
    cnt[a[x]]++;
}
void del(int x){
    cnt[a[x]]--;
    tmp-=cnt[a[x]];
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=1;i<=m;++i){
        int l,r;
        cin>>l>>r;
        que[i]={l,r,i};
        bot[i]=(r-l)*(r-l+1)/2;
    }
    sort(que+1,que+m+1,cmp);
    int l=1,r=0;
    for(int i=1;i<=m;++i){
        while(r<que[i][1])++r,add(r);
        while(l>que[i][0])--l,add(l); 
        while(r>que[i][1])del(r),--r;
        while(l<que[i][0])del(l),++l;
        ans[que[i][2]]=tmp;
    }
    for(int i=1;i<=m;++i){
        int g=gcd(ans[i],bot[i]);
        cout<<ans[i]/g<<'/'<<bot[i]/g<<endl;
    }
    return 0;
}
```
## 权值线段树
```
/*http://oj.daimayuan.top/course/15/problem/52*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,m,root,tot;
const int N=2e5+10,M=30;
struct Node{
	int s[2];
	int sz;
}node[N*32];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	root=++tot;
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		int x;
		cin>>x;
		int p=root;
		for(int j=M-1;j>=0;--j){
			node[p].sz+=1;
			int w=(x>>j)&1;
			if(!node[p].s[w])node[p].s[w]=++tot;
			p=node[p].s[w];
		}
		node[p].sz+=1;
	}
	for(int i=1;i<=m;++i){
		int x,k;
		cin>>x>>k;
		int p=root;
		int ans=0;
		for(int j=M-1;j>=0;--j){
			int w=(x>>j)&1;
			if(node[node[p].s[w]].sz>=k){
				p=node[p].s[w];
			}else {
				k-=node[node[p].s[w]].sz;
				ans^=1<<j;
				p=node[p].s[1^w];  
			}
		}
		cout<<ans<<endl;
	}
	
	return 0;
} 
```
## 树分治
```
/*https://www.acwing.com/problem/content/254/*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N = 10010, M = N * 2;
int n, m;
int h[N], e[M], w[M], ne[M], idx;
bool vis[N];
int p[N], q[N];

void add(int a, int b, int c)
{
    e[++idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx;
}

int dfs1(int u, int fa)  // 求子树大小
{
    if (vis[u]) return 0;
    int res = 1;
    for (int i = h[u]; i!=-1; i = ne[i])
        if (e[i] != fa)
            res += dfs1(e[i], u);
    return res;
}

int dfs2(int u, int fa, int tot, int& wc)  // 求重心
{
    if (vis[u]) return 0;
    int sum = 1, ms = 0;
    for (int i = h[u]; i!=-1; i = ne[i])
    {
        int v = e[i];
        if (v == fa) continue;
        int t = dfs2(v, u, tot, wc);
        ms = max(ms, t);
        sum += t;
    }
    ms = max(ms, tot - sum);
    if (ms <= tot / 2) wc = u;
    return sum;
}

void dfs3(int u, int fa, int dist, int& qt)//求距离
{
    if (vis[u]) return;
    q[qt ++ ] = dist;
    for (int i = h[u]; ~i; i = ne[i])
        if (e[i] != fa)
            dfs3(e[i], u, dist + w[i], qt);
}

int get(int a[], int k)
{
    sort(a, a + k);
    int res = 0;
    for (int i = k - 1, j = -1; i >= 0; i -- )
    {
        while (j + 1 < i && a[j + 1] + a[i] <= m) j ++ ;
        j = min(j, i - 1);
        res += j + 1;
    }
    return res;
}

int calc(int u)
{
    if (vis[u]) return 0;
    int res = 0;
    dfs2(u, -1, dfs1(u, -1), u);
    vis[u] = true;  // 删除重心

    int pt = 0;
    for (int i = h[u]; i!=-1; i = ne[i])
    {
        int v = e[i], qt = 0;
        dfs3(v, -1, w[i], qt);
        res -= get(q, qt);
        for (int k = 0; k < qt; k ++ )
        {
            if (q[k] <= m) res ++ ;
            p[pt ++ ] = q[k];
        }
    }
    res += get(p, pt);

    for (int i = h[u]; i!=-1; i = ne[i]) res += calc(e[i]);
    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    while (cin>>n>>m && (n || m))
    {
        memset(vis, 0, sizeof vis);
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 1; i < n; i ++ )
        {
            int a, b, c;
            cin>>a>>b>>c;
            add(a, b, c), add(b, a, c);
        }
        cout<<calc(0)<<endl;
    }

    return 0;
}
```
## 树哈希
```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;

const int N = 60;
const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

ull shift(ull x) {
    x ^= mask;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    x ^= mask;
    return x;
}

vector<int> edge[N];
ull sub[N], root[N];
map<ull, int> trees;

void getSub(int x) {
    sub[x] = 1;
    for (int i : edge[x]) {
        getSub(i);
        sub[x] += shift(sub[i]);
    }
}

void getRoot(int x) {
    for (int i : edge[x]) {
        root[i] = sub[i] + shift(root[x] - shift(sub[i]));
        getRoot(i);
    }
}

int main() {
    int m;
    cin>>m;
    for (int t = 1; t <= m; t++) {
        int n, rt = 0;
        cin>>n;
        for (int i = 1; i <= n; i++) {
            int fa;
            cin>>fa;
            if (fa) {
                edge[fa].push_back(i);
            } else {
                rt = i;
            }
        }
        getSub(rt);
        root[rt] = sub[rt];
        getRoot(rt);
        ull hash = 1;
        for (int i = 1; i <= n; i++) {
            hash += shift(root[i]);
        }
        if (!trees.count(hash)) {
            trees[hash] = t;
        }
        cout<<trees[hash]<<endl;
        for (int i = 1; i <= n; i++) {
            edge[i].clear();
        }
    }
}

```
## DSU ON TREE
```
/*http://oj.daimayuan.top/course/15/problem/817*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
int n;
const int N=1e5+10;
int l[N],r[N],idd[N],sz[N],hs[N],tot;
int c[N],cnt[N];//每个颜色出现次数
int maxcnt;//众数出现次数
int sumcnt;
int ans[N];
vector<int>e[N];
void add(int x){
    x=c[x];
    cnt[x]++;
    if(cnt[x]>maxcnt)maxcnt=cnt[x],sumcnt=0;
    if(cnt[x]==maxcnt)sumcnt+=x;
}
void del(int x){
    x=c[x];
    cnt[x]--;
}
void dfs1(int u,int f){
    l[u]=++tot;
    idd[tot]=u;
    sz[u]=1;
    hs[u]=-1;
    for(auto &v:e[u]){
        if(v==f)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(hs[u]==-1||sz[v]>sz[hs[u]])
			hs[u]=v;
    }
    r[u]=tot;
}
void dfs2(int u,int f,bool keep){
    for(auto &v:e[u]){
        if(v!=f&&v!=hs[u]){
            dfs2(v,u,0);
        }
    }
    if(hs[u]!=-1){
        dfs2(hs[u],u,1);
    }
    for(auto &v:e[u]){
        if(v!=f &&v!=hs[u]){
            for(int x=l[v];x<=r[v];++x){
                add(idd[x]);
            }
        }
    }
    add(u);
    ans[u]=sumcnt;
    if(!keep){
        sumcnt=0;
        maxcnt=0;
        for(int x=l[u];x<=r[u];++x){
            del(idd[x]);
        }
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n;
    for(int i=1;i<=n;++i)cin>>c[i];
    for(int i=1;i<n;++i){
        int u,v;
        cin>>u>>v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,0,0);
    for(int i=1;i<=n;++i)cout<<ans[i]<<" \n"[i==n];
    return 0;
}
```
## Splay
```
/*https://www.luogu.com.cn/problem/P6136*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10,M=1e6+10,INF=1e18;
int a[N];
int root,idx;
struct Node{
    int s[2];
    int p,v;//p父节点，v值
    int size,cnt;
    void init(int _v,int _p){
        v=_v,p=_p;
        size=cnt=1;
    }
}node[N+M];
void update(int u){
    node[u].size=node[node[u].s[0]].size+node[node[u].s[1]].size+node[u].cnt;
}
void rotate(int x){
    int y=node[x].p,z=node[y].p;
    int ky=node[y].s[1]==x,kz=node[z].s[1]==y;
    node[z].s[kz]=x,node[x].p=z;
    node[y].s[ky]=node[x].s[ky^1],node[node[x].s[ky^1]].p=y;
    node[x].s[ky^1]=y,node[y].p=x;
    update(y),update(x);
}
void splay(int x,int k){
    while(node[x].p!=k){
        int y=node[x].p,z=node[y].p;
        if(z!=k){
            if((node[y].s[1]==x)^(node[z].s[1]==y))rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if(!k)root=x;
}
void find(int v){
    int x=root;
    
    while(node[x].s[v>node[x].v]&&v!=node[x].v)
        x=node[x].s[v>node[x].v];
    splay(x,0);
}
void insert(int v){
    int u=root,p=0;
    while(u&&node[u].v!=v){
        p=u;
        u=node[u].s[v>node[u].v];
    }
    if(u)node[u].cnt++;
    else {
        u=++idx;
        node[p].s[v>node[p].v]=u;
        node[u].init(v,p);
    }
    splay(u,0);
}
int prev(int v){
    find(v);
    int u=root;
    if(node[u].v<v)return u;
    u=node[u].s[0];
    while(node[u].s[1]){
        u=node[u].s[1];
    }
    splay(u,0);
    return u;
}
int nex(int v){
    find(v);
    int u=root;
    if(node[u].v>v)return u;
    u=node[u].s[1];
    while(node[u].s[0]){
        u=node[u].s[0];
    }
    splay(u,0);
    return u;
}
void del(int x){
    int pre=prev(x),ne=nex(x);
    splay(pre,0),splay(ne,pre);
    int d=node[ne].s[0];
    if(node[d].cnt>1)
        node[d].cnt--,splay(d,0);
    else node[ne].s[0]=0,splay(ne,0);
}
int rkx(int u){
    insert(u);
    int res=node[node[root].s[0]].size;
    del(u);
    return res;
}
int getk(int k){
    int u=root;
    while(1){
        int y=node[u].s[0];
        if(node[y].size+node[u].cnt>=k){
            if(node[y].size>=k)u=node[u].s[0];
            else break;
        }
        else {
            k-=node[y].size+node[u].cnt;
            u=node[u].s[1];
        }
    }
    splay(u,0);
    return node[u].v;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,m;
    cin>>n>>m;
    insert(INF),insert(-INF);
    for(int i=1;i<=n;++i){
        int x;
        cin>>x;
        insert(x);
    }
    int res=0,las=0;
    for(int i=1;i<=m;++i){
        int op,x;
        cin>>op>>x;
        x^=las;
        //cout<<"op"<<op<<" "<<x<<endl;
        if(op==1){
            insert(x);
        }else if(op==2){
            del(x);
        }else if(op==3){
            las=rkx(x);
        }else if(op==4){
            las=getk(x+1);
        }else if(op==5){
            las=node[prev(x)].v;
        }else las=node[nex(x)].v;
        //cout<<las<<endl;
        if(op==3||op==4||op==5||op==6)res^=las;
    }
    cout<<res<<endl;
    
    return 0;
}
```
## ST表
```
/*https://www.luogu.com.cn/problem/P3865*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N=1e5+10;
int a[N];
int n,m;
int maxn[N][18];
int log_2[N];
void init()
{
    for(int i=1;i<=n;++i)maxn[i][0]=a[i];
    for(int j=1;(1<<j)<=n;++j){
        for(int i=1;i+(1<<j)-1<=n;++i){
            maxn[i][j]=max(maxn[i][j-1],maxn[i+(1<<j-1)][j-1]);
        }
    }
    for(int i=2;i<=n;++i){
        log_2[i]=log_2[i>>1]+1;
    }
}
int query(int l,int r){
    int k=log_2[r-l+1];
    return max(maxn[l][k],maxn[r-(1<<k)+1][k]);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];
    init();
    for(int i=1;i<=m;++i){
        int l,r;
        cin>>l>>r;
        cout<<query(l,r)<<endl;
    }
    return 0;
}
```
# 数论
## 多项式快速幂
```
#include<bits/stdc++.h>
using namespace std;
constexpr int P = 998244353;
using i64 = long long;
int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, int b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}


struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};

std::vector<int> rev;
std::vector<Z> roots{0, 1};
void dft(std::vector<Z> &a) {
    int n = a.size();
    
    if (int(rev.size()) != n) {
        int k = __builtin_ctz(n) - 1;
        rev.resize(n);
        for (int i = 0; i < n; i++) {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (rev[i] < i) {
            std::swap(a[i], a[rev[i]]);
        }
    }
    if (int(roots.size()) < n) {
        int k = __builtin_ctz(roots.size());
        roots.resize(n);
        while ((1 << k) < n) {
            Z e = power(Z(3), (P - 1) >> (k + 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots[2 * i] = roots[i];
                roots[2 * i + 1] = roots[i] * e;
            }
            k++;
        }
    }
    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                Z u = a[i + j];
                Z v = a[i + j + k] * roots[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}
void idft(std::vector<Z> &a) {
    int n = a.size();
    std::reverse(a.begin() + 1, a.end());
    dft(a);
    Z inv = (1 - P) / n;
    for (int i = 0; i < n; i++) {
        a[i] *= inv;
    }
}
struct Poly {
    std::vector<Z> a;
    Poly() {}
    Poly(const std::vector<Z> &a) : a(a) {}
    Poly(const std::initializer_list<Z> &a) : a(a) {}
    int size() const {
        return a.size();
    }
    void resize(int n) {
        a.resize(n);
    }
    Z operator[](int idx) const {
        if (idx < size()) {
            return a[idx];
        } else {
            return 0;
        }
    }
    Z &operator[](int idx) {
        return a[idx];
    }
    Poly mulxk(int k) const {
        auto b = a;
        b.insert(b.begin(), k, 0);
        return Poly(b);
    }
    Poly modxk(int k) const {
        k = std::min(k, size());
        return Poly(std::vector<Z>(a.begin(), a.begin() + k));
    }
    Poly divxk(int k) const {
        if (size() <= k) {
            return Poly();
        }
        return Poly(std::vector<Z>(a.begin() + k, a.end()));
    }
    friend Poly operator+(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] + b[i];
        }
        return Poly(res);
    }
    friend Poly operator-(const Poly &a, const Poly &b) {
        std::vector<Z> res(std::max(a.size(), b.size()));
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = a[i] - b[i];
        }
        return Poly(res);
    }
    friend Poly operator*(Poly a, Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int sz = 1, tot = a.size() + b.size() - 1;
        while (sz < tot) {
            sz *= 2;
        }
        a.a.resize(sz);
        b.a.resize(sz);
        dft(a.a);
        dft(b.a);
        for (int i = 0; i < sz; ++i) {
            a.a[i] = a[i] * b[i];
        }
        idft(a.a);
        a.resize(tot);
        return a;
    }
    friend Poly operator*(Z a, Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }
    friend Poly operator*(Poly a, Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }
    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }
    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }
    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }
    Poly deriv() const {
        if (a.empty()) {
            return Poly();
        }
        std::vector<Z> res(size() - 1);
        for (int i = 0; i < size() - 1; ++i) {
            res[i] = (i + 1) * a[i + 1];
        }
        return Poly(res);
    }
    Poly integr() const {
        std::vector<Z> res(size() + 1);
        for (int i = 0; i < size(); ++i) {
            res[i + 1] = a[i] / (i + 1);
        }
        return Poly(res);
    }
    Poly inv(int m) const {
        Poly x{a[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - modxk(k) * x)).modxk(k);
        }
        return x.modxk(m);
    }
    Poly log(int m) const {
        return (deriv() * inv(m)).integr().modxk(m);
    }
    Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + modxk(k))).modxk(k);
        }
        return x.modxk(m);
    }
    Poly pow(int k, int m) const {
        int i = 0;
        while (i < size() && a[i].val() == 0) {
            i++;
        }
        if (i == size() || 1LL * i * k >= m) {
            return Poly(std::vector<Z>(m));
        }
        Z v = a[i];
        auto f = divxk(i) * v.inv();
        return (f.log(m - i * k) * k).exp(m - i * k).mulxk(i * k) * power(v, k);
    }
    Poly sqrt(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);
        }
        return x.modxk(m);
    }
    Poly mulT(Poly b) const {
        if (b.size() == 0) {
            return Poly();
        }
        int n = b.size(); // eb + 1
        std::reverse(b.a.begin(), b.a.end());
        return ((*this) * b).divxk(n - 1); //保留系数(x ^ eb)及以上的
    }
    std::vector<Z> eval(std::vector<Z> x) const {
        if (size() == 0) {
            return std::vector<Z>(x.size(), 0);
        }
        const int n = std::max(int(x.size()), size());
        std::vector<Poly> q(4 * n);
        std::vector<Z> ans(x.size());
        x.resize(n);
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                q[p] = Poly{1, -x[l]};
            } else {
                int m = (l + r) / 2;
                build(2 * p, l, m);
                build(2 * p + 1, m, r);
                q[p] = q[2 * p] * q[2 * p + 1];
            }
        };
        build(1, 0, n);
        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {
            if (r - l == 1) {
                if (l < int(ans.size())) {
                    ans[l] = num[0];
                }
            } else {
                int m = (l + r) / 2;
                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));
                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));
            }
        };
        work(1, 0, n, mulT(q[1].inv(n)));
        return ans;
    }
};
```
## 高斯消元
```
/*https://www.acwing.com/problem/content/description/885/*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e2+10;
const double eps=1e-8;
double a[N][N];
int n;
int gauss(){
    int c,r;
    for(c=1,r=1;c<=n;++c){
        int t=r;
        for(int i=r;i<=n;++i)//找绝对值最大的行
            if(fabs(a[i][c])>fabs(a[t][c]))
                t=i;
        if(fabs(a[t][c])<eps)continue;
        for(int i=c;i<=n+1;++i)swap(a[t][i],a[r][i]);// 将绝对值最大的行换到最顶端
        for(int i=n+1;i>=c;--i)a[r][i]/=a[r][c];// 将当前行的首位变成1
        for(int i=r+1;i<=n;++i){// 用当前行将下面所有的列消成0
            if(fabs(a[i][c])>eps){
                for(int j=n+1;j>=c;--j){
                    a[i][j]-=a[r][j]*a[i][c];
                }
            }
        }
        ++r;
    }
    if(r<=n){
        for(int i=r;i<=n;++i){
            if(fabs(a[i][n+1])>eps)return 2;
        }
        return 1;
    }
    for(int i=n;i>=1;--i){
        for(int j=i+1;j<=n;++j){
            a[i][n+1]-=a[i][j]*a[j][n+1];
        }
    }
    return 0;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cout.setf(ios::fixed);
    cout.precision(2);
    
    
    cin>>n;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n+1;++j){
            cin>>a[i][j];
        }
    }
    int t=gauss();
    if(t==2)cout<<"No solution"<<endl;
    else if(t==1)cout<<"Infinite group solutions"<<endl;
    else {
        for(int i=1;i<=n;++i)cout<<a[i][n+1]<<endl;
    }

    return 0;
}
```
## 快速幂
```
/*https://www.acwing.com/problem/content/description/877/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int qmi(int a,int b,int p){
    int res=1;
    while(b){
        if(b&1)res=res*a%p;
        a=a*a%p;
        b>>=1;
    }
    return res;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		int a,b,p;
		cin>>a>>b>>p;
		cout<<qmi(a,b,p)<<endl;
	}
	
	return 0;
} 
```
## 扩展中国剩余定理
```
/*https://www.luogu.com.cn/problem/P4777*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
int a[N],b[N];
int n;
int mul(int a,int b,int mod)
{
    int res=0;
    while(b>0)
    {
        if(b&1) res=(res+a)%mod;
        a=(a+a)%mod;
        b>>=1;
    }
    return res;
}
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
int excrt(){
    int x,y,k;
    int M=b[1],ans=a[1];
    for(int i=2;i<=n;++i){
        int aa=M,bb=b[i],c=(a[i]-ans%bb+bb)%bb;
        int d=exgcd(aa,bb,x,y),bd=bb/d;
        if(c%d!=0)return -1;
        //x=x%bd*(int)(c/d)%bd;
        x=mul(x,c/d,bd);
        ans+=x*M;
        M*=bd;
        ans=(ans%M+M)%M;
    }
    return (ans%M+M)%M;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n;
    for(int i=1;i<=n;++i)cin>>b[i]>>a[i];
    cout<<excrt()<<endl;

    return 0;
}
```
## 立方和
$1^3+2^3+...+n^3=(1+2+...+n)^2$
## 求解二元一次不定方程
```
/*https://www.luogu.com.cn/problem/P5656*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
int a[N];
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
void solve()
{
    int a,b,c;
    cin>>a>>b>>c;
    int x,y;
    int d=exgcd(a,b,x,y);
    if(c%d)cout<<-1<<endl;
    else {//ceil向上取整
        x*=c/d,y*=c/d;
        int p=b/d,q=a/d,k;//a*(x+p)+b*(y-q)=c,a*x+b*y=c,解得p=b*q/a,
        //又因为p,q为正整数,所以b*q=lcm(a,b)=a*b/d,可求得pq
        if(x<0)k=ceil((1.0-x)/p),x+=p*k,y-=q*k;//x+k*p>=1,将x升到最小正整数
        else k=(x-1)/p,x-=p*k,y+=q*k;//将x缩到最小正整数
        if(y>0){
            cout<<(y-1)/q+1<<" "<<x<<" "<<(y-1)%q+1<<" "<<x+(y-1)/q*p<<" "<<y<<endl;
        }else {//无正整数解
            cout<<x<<" "<<y+q*(int)ceil((1.0-y)/q)<<endl;
        }
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin>>T;
    while(T--)	solve();
    return 0;
}
```
## 质数
```c++
int pdiv(int n) {
        if(check(n)) return 1;        
        if(n%2 == 0) return 2;     
        if(check(n-2)) return 2;      
        return 3;              
}
```

一个数最多能被分成$\frac{n}{2}$个质数，最少能分解成$pdiv(n)$个质数，在这范围内个质数都能实现
## 中国剩余定理
```
/*https://www.luogu.com.cn/problem/P1495*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=25+10;
int a[N],m[N];

int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
int crt(int n){
    int M = 1, ans = 0;
    for (int i = 1; i <= n; i++) M = M * m[i];
    for (int i = 1; i <= n; i++) {
        int k = M/m[i],x,y;
        exgcd(k, m[i], x, y);  //  k*x  = 1 mod m[i]
        ans = (ans + a[i]*k*x % M) % M;
    }
    return (ans % M + M) % M;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int n;
    cin>>n;
    for(int i=1;i<=n;++i)cin>>m[i]>>a[i];
    cout<<crt(n)<<endl;  
 
    return 0;
}
```
## 组合数
```
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=1e4+10;
const int mod=1e9+7,p=1e9+7;
//1.数据量大，a,b值小
int c[N][N];
void init1(){
	for(int i=0;i<N;i++){
		for(int j=0;j<=i;j++){//注意是<=
			if(!j) c[i][j]=1;//初始化
			else c[i][j]=c[i-1][j]+c[i-1][j-1];//递推公式
		}
	}
}


//2.数据量小，a,b值较大

int fact[N],infact[N];
int qmi(int a,int k,int p){//快速幂
	int res=1;
	while(k){
		if(k&1) res=res*a%p;
		k>>=1;
		a=a*a%p;
	}
	return res;
}
 
void init2(){//预处理阶乘数组和乘法逆元数组
	fact[0]=infact[0]=1;
	for(int i=1;i<N;i++){
		fact[i]=fact[i-1]*i%mod;
		infact[i]=infact[i-1]*qmi(i,mod-2,mod)%mod;//用快速幂求乘法逆元
	}
}
int get(int a,int b){//Ca取b
    int res=fact[a]*infact[b]%mod*infact[a-b]%mod;//代入公式求解组合数
    return res;
}


//3.a,b非常大，仅求同模p的值
int C(int a,int b){
	int res=1;
	for(int i=1,j=a;i<=b;i++,j--){
		res=res*j%p;
		res=res*qmi(i,p-2,p)%p;//除以一个数转化为乘它的乘法逆元
	}
	return res;
}
 
int lucas(int a,int b){
	if(a<p&&b<p) return C(a,b);//a,b都小于p，定义求解
	return C(a%p,b%p)*lucas(a/p,b/p)%p;//代入卢卡斯公式
}

//4.a,b非常大，求具体值
int primes[N],cnt=0;
bool st[N];
int sum[N];//储存质因数个数
 
 
void get_primes(int n){//线性筛法分解质因数
	for(int i=2;i<=n;i++){
		if(!st[i]) primes[cnt++]=i;	
		for(int j=0;primes[j]<=n/i;j++){
			st[primes[j]*i]=true;
			if(i%primes[j]==0) break;
		}		
	}
}
 
int get(int n,int p){//求质因数个数
	int res=0;
	while(n){
		res+=n/p;
		n/=p;
	}
	return res;
}
 
vector<int> mul(vector<int> &A,int b){//高精度乘法
	vector<int> C;
	int t=0;
	for(int i=0;i<A.size()||t;i++){
		if(i<A.size()) t+=A[i]*b;
		C.push_back(t%10);
		t/=10;
	}
	return C;
}
 
signed main(){
    int a,b;
	cin>>a>>b;
 
	get_primes(a);//分解分子的质因数
 
	for(int i=0;i<cnt;i++){
		int p=primes[i];
		sum[i]=get(a,p)-get(b,p)-get(a-b,p);//分子、分母中消去相同质因数p后的个数
	}
 
	vector<int> res;
	res.push_back(1);
	for(int i=0;i<cnt;i++){
		for(int j=0;j<sum[i];j++){
			res=mul(res,primes[i]);
		}
	}
	for(int i=res.size()-1;i>=0;i--) cout<<res[i];
	
	return 0;
}


//5.卡特兰数
```
## crt
中国剩余定理：一个解为$x=\sum_{i=1}^ka_i\frac{M}{m_i}t_i$通解为$x+i*M$最小非负整数解为$(x\%M+M)\%M$
扩展：已求出前$k-1$个方程组成的同余方程组的一个解$x$,$M=lcm_{i-1}^{k-1}$，则前m个方程组的通解为$x+i*M$
加入第k个方程后，需求t，使得$x+t*M=a_k\quad mod\quad m_k$,即$t*M=a_k-x (mod\quad m_k)$，所以$x_k=x+t*M$
## exgcd
```
/*https://www.acwing.com/problem/content/879/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		int a,b;
		cin>>a>>b;
		int x,y;
		exgcd(a,b,x,y);
		cout<<x<<" "<<y<<endl;
	}
	
	return 0;
} 
```
## gcd
gcd(a,b)=gcd(a,b−a)

```c++
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
```
## Pollard Pho
```
/*https://www.luogu.com.cn/problem/P4718*/
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int t;
long long max_factor, n;

long long gcd(long long a, long long b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}

long long quick_pow(long long x, long long p, long long mod) {  // 快速幂
  long long ans = 1;
  while (p) {
    if (p & 1) ans = (__int128)ans * x % mod;
    x = (__int128)x * x % mod;
    p >>= 1;
  }
  return ans;
}

bool Miller_Rabin(long long p) {  // 判断素数
  if (p < 2) return 0;
  if (p == 2) return 1;
  if (p == 3) return 1;
  long long d = p - 1, r = 0;
  while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
  for (long long k = 0; k < 10; ++k) {
    long long a = rand() % (p - 2) + 2;
    long long x = quick_pow(a, d, p);
    if (x == 1 || x == p - 1) continue;
    for (int i = 0; i < r - 1; ++i) {
      x = (__int128)x * x % p;
      if (x == p - 1) break;
    }
    if (x != p - 1) return 0;
  }
  return 1;
}

long long Pollard_Rho(long long x) {
  long long s = 0, t = 0;
  long long c = (long long)rand() % (x - 1) + 1;
  int step = 0, goal = 1;
  long long val = 1;
  for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
    for (step = 1; step <= goal; ++step) {
      t = ((__int128)t * t + c) % x;
      val = (__int128)val * abs(t - s) % x;
      if ((step % 127) == 0) {
        long long d = gcd(val, x);
        if (d > 1) return d;
      }
    }
    long long d = gcd(val, x);
    if (d > 1) return d;
  }
}

void fac(long long x) {
  if (x <= max_factor || x < 2) return;
  if (Miller_Rabin(x)) {              // 如果x为质数
    max_factor = max(max_factor, x);  // 更新答案
    return;
  }
  long long p = x;
  while (p >= x) p = Pollard_Rho(x);  // 使用该算法
  while ((x % p) == 0) x /= p;
  fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
  scanf("%d", &t);
  while (t--) {
    srand((unsigned)time(NULL));
    max_factor = 0;
    scanf("%lld", &n);
    fac(n);
    if (max_factor == n)  // 最大的质因数即自己
      printf("Prime\n");
    else
      printf("%lld\n", max_factor);
  }
  return 0;
}
```
# 图论
## 网络流
### 最大流
```
/*https://www.luogu.com.cn/problem/P3376*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=5e3+10;
int n,m,s,t;
int e[N*N],w[N*N],nex[N*N],h[N],idx=1;
int pre[N];
int mf[N];//s~v上的流量上限
void add(int a,int b,int c){
    e[++idx]=b;
    w[idx]=c;
    nex[idx]=h[a];
    h[a]=idx;
}
bool bfs(){
    for(int i=0;i<=n;++i)mf[i]=0;
    queue<int>q;
    q.push(s);
    mf[s]=1e9;
    while(q.size()){
        int u=q.front();
        q.pop();
        for(int i=h[u];i!=-1;i=nex[i]){
            int v=e[i];
            if(mf[v]==0&&w[i]){
                mf[v]=min(mf[u],w[i]);
                pre[v]=i;
                q.push(v);
                if(v==t)return true;
            }
        }
    }
    return false;
}
int EK(){
    int flow=0;
    while(bfs()){
        int v=t;
        while(v!=s){
            int i=pre[v];
            w[i]-=mf[t];
            w[i^1]+=mf[t];
            v=e[i^1];
        }
        flow+=mf[t];
    }
    return flow;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m>>s>>t;
    for(int i=0;i<=n;++i)h[i]=-1;
    for(int i=1;i<=m;++i){
        int a,b,c;
        cin>>a>>b>>c; 
        add(a,b,c);
        add(b,a,0);
    }
    cout<<EK()<<endl;
    return 0;
}
```
### 最小割
```
#include<bits/stdc++.h>
using namespace std;

const int N = 1e4 + 5, M = 2e5 + 5;
int n, m, s, t, tot = 1, lnk[N], ter[M], nxt[M], val[M], dep[N], cur[N];

void add(int u, int v, int w) {
    ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, val[tot] = w;
}

void addedge(int u, int v, int w) { 
    add(u, v, w), add(v, u, 0); 
}

int bfs(int s, int t) {
    memset(dep, 0, sizeof(dep));
    memcpy(cur, lnk, sizeof(lnk));
    queue<int> q;
    q.push(s), dep[s] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = lnk[u]; i; i = nxt[i]) {
            int v = ter[i];
            if (val[i] && !dep[v]) q.push(v), dep[v] = dep[u] + 1;
        }
    }
    return dep[t];
}

int dfs(int u, int t, int flow) {
    if (u == t) return flow;
    int ans = 0;
    for (int &i = cur[u]; i && ans < flow; i = nxt[i]) {
        int v = ter[i];
        if (val[i] && dep[v] == dep[u] + 1) {
            int x = dfs(v, t, min(val[i], flow - ans));
            if (x) val[i] -= x, val[i ^ 1] += x, ans += x;
        }
    }
    if (ans < flow) dep[u] = -1;
    return ans;
}

int dinic(int s, int t) {
    int ans = 0;
    while (bfs(s, t)) {
        int x;
        while ((x = dfs(s, t, 1 << 30))) ans += x;
    }
    return ans;
}

int main() {
    scanf("%d%d%d%d", &n, &m, &s, &t);
    while (m--) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        addedge(u, v, w);
    }
    printf("%d\n", dinic(s, t));
    return 0;
}

```
### 费用流（最小费用最大流）
```
/*https://www.luogu.com.cn/problem/P3381*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=5e3+10;
int n,m,s,t;
int e[N*N],w[N*N],cs[N*N],nex[N*N],h[N],idx=1;
int pre[N],mf[N],d[N],vis[N];
void add(int a,int b,int c,int d){
    e[++idx]=b;
    cs[idx]=c;
    w[idx]=d;
    nex[idx]=h[a];
    h[a]=idx;
}
bool spfa(){
    for(int i=0;i<=n;++i)mf[i]=0,d[i]=0x3f3f3f3f;
    queue<int>q;
    q.push(s);
    d[s]=0;
    mf[s]=1e9;
    vis[s]=1;
    while(q.size()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=h[u];i!=-1;i=nex[i]){
            int v=e[i];
            if(d[v]>d[u]+w[i]&&cs[i]){
                d[v]=d[u]+w[i];
                mf[v]=min(mf[u],cs[i]);
                pre[v]=i;
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
    return mf[t]>0;
}
int flow=0,cost=0;
void EK(){
    while(spfa()){
        int v=t;
        while(v!=s){
            int i=pre[v];
            cs[i]-=mf[t];
            cs[i^1]+=mf[t];
            v=e[i^1];
        }
        flow+=mf[t];
        cost+=mf[t]*d[t];
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m>>s>>t;
    for(int i=0;i<=n;++i)h[i]=-1;
    for(int i=1;i<=m;++i){
        int a,b,c,d;
        cin>>a>>b>>c>>d; 
        add(a,b,c,d);
        add(b,a,0,-d);
    }
    EK();
    cout<<flow<<" "<<cost<<endl;
    return 0;
}
```
## 割边
```
/*https://www.luogu.com.cn/problem/P8436*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=5e5+10,M=2e6+10;
int n,m;
vector<pair<int,int> >e[N];
vector<vector<int> >res;
int cnt;
stack<int>stk;
vector<pair<int,int> >bridge;
int dfn[N],low[N],tot;
void dfs(int u,int idd){
    dfn[u]=low[u]=++tot;
    stk.push(u);
    for(auto &temp:e[u]){
        int v=temp.first,id=temp.second;
        if(id!=idd){//非反向边
            if(!dfn[v]){
                dfs(v,id);
                low[u]=min(low[u],low[v]);
                //if(low[v]>dfn[u])bridge.push_back({u,v});//求割边
            }else if(idd!=id){
                low[u]=min(low[u],dfn[v]);
            }
        }
        
        
    }
    if(dfn[u]==low[u]){//求边连通分量
            vector<int>t1;
            ++cnt;
            while(1){
                int vv=stk.top();
                stk.pop();
                t1.push_back(vv);
                if(u==vv)break;
            }
            sort(t1.begin(),t1.end());
            res.push_back(t1);
        }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n>>m;
    for(int i=1;i<=m;++i){
        int a,b;
        cin>>a>>b;
        e[a].push_back({b,i});
        e[b].push_back({a,i});
    }
    for(int i=1;i<=n;++i){
        if(!dfn[i])dfs(i,-1);
    }
    cout<<cnt<<endl;
    sort(res.begin(),res.end());
    for(auto &x:res){
        cout<<x.size()<<" ";
        for(auto &y:x){
            cout<<y<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
## 割点
```
/*https://www.luogu.com.cn/problem/P8435*/
#include<bits/stdc++.h>//割点为属于至少两个双连通分量的点
#define int long long
using namespace std;
#define endl '\n'
const int N=5e5+10,M=2e6+10;
int n,m;
int e[M*2],nex[M*2],h[N],idx;
vector<vector<int> >res;
vector<int>cut;
stack<int>stk;
int cnt;
void add(int a,int b){
    e[++idx]=b;
    nex[idx]=h[a];
    h[a]=idx;
}
int dfn[N],low[N],tot,deg[N];
void dfs(int u,int f){
    dfn[u]=low[u]=++tot;
    int child=0;
    stk.push(u);
    for(int i=h[u];i!=-1;i=nex[i]){
        int v=e[i];
        if(v==f)continue;
        if(!dfn[v]){
            dfs(v,u);
            ++child;
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]){
                //++deg[u];//割点
                vector<int>temp;
                temp.push_back(u);
                ++cnt;
                while(1){
                    int vv=stk.top();
                    //deg[vv]++;
                    stk.pop();
                    temp.push_back(vv);
                    if(vv==v)break;
                }
                sort(temp.begin(),temp.end());
                res.push_back(temp);
            }

        }else {
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(child==0&&f==0){
        vector<int>temp;
        ++cnt;
        temp.push_back(u);
        res.push_back(temp);
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    for(int i=0;i<=n;++i)h[i]=-1;

    for(int i=1;i<=m;++i){
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    for(int i=1;i<=n;++i){
        if(!dfn[i])dfs(i,0);
    }
    cout<<cnt<<endl;
    sort(res.begin(),res.end());
    for(auto &x:res){
        cout<<x.size()<<" ";
        for(auto &y:x){
            cout<<y<<" ";
        }
        cout<<endl;
    }
    /*for(int i=1;i<=n;++i){
        if(deg[i]>1)cut.push_back(i);
    }
    cout<<cut.size()<<endl;
    for(auto &x:cut){
        cout<<x<<" ";
    }
    cout<<endl;*/
    return 0;
}
```
## 染色法判断二分图
```
/*https://www.acwing.com/problem/content/862/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=2e5+10;
int color[N];
int e[N],h[N],nex[N],idx;//无向边，边的实际最大数量应该定义为点的两边
void add(int a,int b){
	e[++idx]=b,nex[idx]=h[a],h[a]=idx;
}
bool dfs(int u,int f){
	color[u]=f;
	
	for(int i=h[u];i!=-1;i=nex[i]){
		int v=e[i];
		//cout<<u<<" "<<v<<" "<<color[v]<<" "<<f<<endl;
		if(!color[v]){
			if(!dfs(v,3-f))return false;
		}else if(color[v]==f)return false;
	}
	return true;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	memset(h,-1,sizeof h);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	bool flag=true;
	for(int i=1;i<=n;++i){
		if(!color[i]){
			if(!dfs(i,1)){
				flag=false;
				break;
			}
		}
	}
	if(flag)cout<<"Yes"<<endl;
	else cout<<"No"<<endl;
	return 0;
} 
```
## 强连通分量
```
/*http://oj.daimayuan.top/course/23/problem/943*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=1e5+10;
int n,m,idx=0;
int dfn[N],low[N];
bool ins[N];
vector<int>vec[N];
stack<int>stk;
vector<vector<int> >res;
void dfs(int u){
	dfn[u]=low[u]=++idx;
	ins[u]=1;
	stk.push(u);
	/*for(auto v:vec[u]){
		if(!dfn[v]){
			dfs(v);
			low[u]=min(low[u],low[v]);
		}else{
			if(ins[v])low[u]=min(dfn[v],low[u]);
		} 
	}*/
	for(auto v:vec[u]){
		if(!dfn[v])dfs(v);
		if(ins[v])low[u]=min(low[u],low[v]);
	}
	if(dfn[u]==low[u]){
		vector<int>temp;
		while(1){
			int v=stk.top();
			temp.push_back(v);
			ins[v]=0;
			stk.pop();
			if(u==v)break;
		}
		sort(temp.begin(),temp.end());
		res.push_back(temp);
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int u,v;
		cin>>u>>v;
		vec[u].push_back(v);
	}
	for(int i=1;i<=n;++i){
		if(!dfn[i])dfs(i);
	}
	sort(res.begin(),res.end());
	for(auto x:res){
		for(auto y:x){
			cout<<y<<" ";
		}
		cout<<endl;
	}
	return 0;
} 
```
## 拓扑排序
```
/*https://www.acwing.com/problem/content/description/850/*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
int n,m;
int e[N],h[N],ne[N],cnt;
int ind[N];
void add(int a,int b)
{
    e[cnt]=b,ne[cnt]=h[a],h[a]=cnt++;
}
queue<int>q,ans;
void topu()
{
    while(!q.empty())
    {
        int tmp=q.front();
        q.pop();
        ans.push(tmp);
        for(int i=h[tmp];i!=-1;i=ne[i])
        {
            int j=e[i];
            ind[j]--;
            if(ind[j]==0)
                q.push(j);
        }
    }

    if(ans.size()!=n)
    {
        cout<<-1<<endl;   
    }
    else
    {
        while(!ans.empty())
        {
            cout<<ans.front()<<" ";
            ans.pop();
        }
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    memset(h,-1,sizeof(h));
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        add(x,y);
        ind[y]++;
    }
    for(int i=1;i<=n;i++)
        if(ind[i]==0)
            q.push(i);
    topu();
    
    return 0;
}
```
## 匈牙利算法
```
/*https://www.acwing.com/problem/content/863/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n1,n2,m;
const int N=510,M=1e5+10;;
int e[M],ne[M],h[N],idx;
int match[N];
bool vis[N];
void add(int a,int b){
    e[++idx]=b,ne[idx]=h[a],h[a]=idx;
}
bool find(int u){
    for(int i=h[u];i!=-1;i=ne[i]){
        int v=e[i];
        if(!vis[v]){
            vis[v]=true;
            if(match[v]==0||find(match[v])){
                match[v]=u;
                return true;
            }
        }
    }
    return false;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    memset(h,-1,sizeof h);
	cin>>n1>>n2>>m;
    for(int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        add(u,v);
    }
	
    int res=0;
    for(int i=1;i<=n1;++i){
        memset(vis,false,sizeof vis);
        if(find(i))++res;
    }
    cout<<res<<endl;
	return 0;
} 
```
## 最小环
```
/*https://www.luogu.com.cn/problem/P6175*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
int n,m;
const int N=110,M=5e3+10;
ll w[N][N],d[N][N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            if(i!=j)w[i][j]=d[i][j]=1e18;
        }
    }
    for(int i=1;i<=m;++i){
        int x,y,val;
        cin>>x>>y>>val;
        w[x][y]=d[x][y]=d[y][x]=w[y][x]=val;
    }
    ll ans=1e18;
    for(int k=1;k<=n;++k){
        for(int i=1;i<k;++i){
            for(int j=i+1;j<k;++j){
                ans=min(ans,d[i][j]+w[i][k]+w[k][j]);
            }
        }
        for(int i=1;i<=n;++i){
            for(int j=1;j<=n;++j){
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
            }
        }
    }
    if(ans!=1e18)cout<<ans<<endl;
    else cout<<"No solution."<<endl;
    return 0;
}
```
## 最小生成树
```
/*https://www.acwing.com/problem/content/description/1142/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int N=1e2+10;
int g[N][N];
int vis[N],dis[N];
int n;
/*void prim(int s)
{
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    int res=0;
    for(int i=0;i<n;i++)
    {
        int t=-1;
        for(int j=1;j<=n;j++)
            if(!vis[j]&&(t==-1||dis[j]<dis[t])) 
                t=j;
        vis[t]=true;
        res+=dis[t];
        for(int j=1;j<=n;j++)   
            dis[j]=min(dis[j],g[t][j]);
    }
    cout<<res<<endl;
}*/
int e[N*N],w[N*N],ne[N*N],h[N],idx;
void add(int a,int b,int c){
    e[++idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx;
}
typedef pair<int,int>pp;
priority_queue<pp,vector<pp>,greater<pp> >pq;
void prim(int s)
{
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    int res=0;
    pq.push({0,s});
    while(!pq.empty()){
        int u=pq.top().second;
        pq.pop();
        if(vis[u])continue;
        vis[u]=true;
        res+=dis[u];
        for(int i=h[u];i!=-1;i=ne[i]){
            int v=e[i];
            if (!vis[v] && w[i] < dis[v]) {
                dis[v] = w[i];
                pq.push({dis[v], v});
            }
        }
    }
    cout<<res<<endl;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
    memset(h,-1,sizeof h);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            int x;
            cin>>x;
            add(i,j,x);
        }
            
    prim(1);
	
	return 0;
} 
```
## Dijkstra
```
/*https://www.acwing.com/problem/content/description/851/*/
#include<bits/stdc++.h>
#define int long long
/*------------------如果定义为long long则memset(dis,0x3f,sizeof dis)之后的数组每个元素都变为0x3f3f3f3f3f3f3f3f,8个3f*/
#define endl '\n' 
using namespace std;
int n,m;
const int N=510,M=1e5+10;
int e[M],ne[M],w[M],h[N],idx;
int dis[N],vis[N];
typedef pair<int,int> pp;
priority_queue<pp,vector<pp>,greater<pp> > q;
void add(int a,int b,int c){
    e[++idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx;
}
void dijk(int s){
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    q.push(pp(0,s));
    while(!q.empty()){
        //cout<<dis[n]<<endl;
        int w1=q.top().first,u=q.top().second;
        //cout<<u<<" "<<w1<<endl;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(int i=h[u];i!=-1;i=ne[i]){
            int v=e[i];
            if(dis[v]>w1+w[i]){
                dis[v]=w1+w[i];
                q.push(pp(dis[v],v));
            }
        }
    }
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	memset(h,-1,sizeof h);
	cin>>n>>m;
	for(int i=1;i<=m;++i){
	    int u,v,w;
	    cin>>u>>v>>w;
	    add(u,v,w);
	}
	
	dijk(1);
	//cout<<0x3f3f3f3f<<endl;
	if(dis[n]==0x3f3f3f3f3f3f3f3f)cout<<-1<<endl;
	else cout<<dis[n]<<endl;
	return 0;
} 
```
## Johnson
```
/*https://www.luogu.com.cn/problem/P5905*/
#include<bits/stdc++.h>

using namespace std;
#define endl '\n'
typedef long long ll;
const int N=3e3+10, M=6e3+10,inf=0x3f3f3f3f,INF=1e9;
int e[N*N],w[N*N],nex[N*N],h[N],idx;
int n,m;
ll vis[N],dis[N],d[N];
void add(int a,int b,int c){
    e[++idx]=b;
    w[idx]=c;
    nex[idx]=h[a];
    h[a]=idx;
}
queue<int>q;
void spfa(int s){
    memset(d,0x3f,sizeof d);
    memset(vis,0,sizeof vis);
    d[s]=0;
    vis[s]=1;
    q.push(s);
    
    while(q.size()){
    	//cout<<"OK"<<endl;
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=h[u];i!=-1;i=nex[i]){
        
            int v=e[i];
            //cout<<v<<endl;
            if(d[v]>d[u]+w[i]){
                d[v]=d[u]+w[i];
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
int cnt[N];
bool spfa2(){
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    for(int s=1;s<=n;++s){
        dis[s]=inf;
        vis[s]=1;
        q.push(s);
    }
    dis[1]=0;
    while(q.size()){
	 
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=h[u];i!=-1;i=nex[i]){
            int v=e[i];
            if(dis[v]>dis[u]+w[i]){
                dis[v]=dis[u]+w[i];
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                    cnt[v]=cnt[u]+1;
                    if(cnt[v]>=n)return true;
                }
            }
        }
    }
    return false;
}
typedef pair<ll,int> pp;
priority_queue<pp,vector<pp>,greater<pp> >pq;
void dijk(int s){
    for(int i=1;i<=n;++i)dis[i]=inf;
    memset(vis,0,sizeof vis);
    dis[s]=0;
    pq.push((pp){0,s});
    while(pq.size()){
	
        int u=pq.top().second;
        pq.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(int i=h[u];i!=-1;i=nex[i]){
            int v=e[i];
            //cout<<u<<" "<<v<<" "<<dis[u]<<" "<<dis[v]<<" "<<w[i]<<endl;
            if(dis[v]>dis[u]+w[i]){
                dis[v]=dis[u]+w[i];
                pq.push((pp){dis[v],v});
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<=m;++i){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    if(spfa2())cout<<-1<<endl;
    else {
    	
        for(int i=1;i<=n;++i){
            add(n+1,i,0);
        }
        spfa(n+1);
        for(int u=1;u<=n;++u){
            for(int i=h[u];i!=-1;i=nex[i]){
                int v=e[i];
                w[i]+=d[u]-d[v];
                //cout<<u<<" "<<v<<" "<<d[u]<<" "<<d[v]<<" "<<w[i]<<endl;
            }
        }
        
        for(int i=1;i<=n;++i){
            ll ans=0;
            dijk(i);
            for(int j=1;j<=n;++j){
                
                if(dis[j]==inf)ans+=(ll)INF*j;
                else ans+=(dis[j]+d[j]-d[i])*j;
                //cout<<i<<" "<<j<<" "<<dis[j]<<" "<<(dis[j]+d[j]-d[i])<<endl;
            }
            cout<<ans<<endl;
            
        }
    }
    
    return 0;
}
```
## LCA
```
/*https://www.acwing.com/problem/content/1174/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,cnt=0;
const int N=4e4+10;
int head[N],to[N],nex[N],dep[N],fa[N][16];
void add(int a,int b){
    to[cnt]=b;
    nex[cnt]=head[a];
    head[a]=cnt++;
}
queue<int>q;
void bfs(int rt){
    memset(dep,0x3f,sizeof dep);
    dep[0]=0,dep[rt]=1;
    q.push(rt);
    while(q.size()){
        int temp=q.front();
        q.pop();
        for(int i=head[temp];i!=-1;i=nex[i]){
            int j=to[i];
            if(dep[j]>dep[temp]+1){
                dep[j]=dep[temp]+1;
                q.push(j);
                fa[j][0]=temp;
                for(int k=1;k<=15;++k){
                    fa[j][k]=fa[fa[j][k-1]][k-1];
                }
            }
        }
    }
}
int lca(int a,int b){
    if(dep[a]<dep[b])swap(a,b);
    for(int k=15;k>=0;--k){
        if(dep[fa[a][k]]>=dep[b]){
            a=fa[a][k];
        }
    }
    if(a==b)return a;
    for(int k=15;k>=0;--k){
        if(fa[a][k]!=fa[b][k]){
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	memset(head,-1,sizeof head);
	int rt=0;
	for(int i=1;i<=n;++i){
	    int a,b;
	    cin>>a>>b;
	    if(b==-1)rt=a;
	    else {
	        add(a,b);
	        add(b,a);
	    }
	    
	}
	bfs(rt);
	
	int m;
	cin>>m;
	while(m--){
	    int a,b;
	    cin>>a>>b;
	    int p=lca(a,b);
	    if(p==a)cout<<1<<endl;
	    else if(p==b)cout<<2<<endl;
	    else cout<<3<<endl;
	}
	
	return 0;
} 
```
## SPFA
```
/*https://www.acwing.com/problem/content/description/853/*/
#include<bits/stdc++.h>
#define int long long
/*------------------如果定义为long long则memset(dis,0x3f,sizeof dis)之后的数组每个元素都变为0x3f3f3f3f3f3f3f3f,8个3f*/
#define endl '\n' 
#define endl '\n' 
using namespace std;
int n,m;
const int N=1e5+10;
int e[N],w[N],ne[N],h[N],idx;
int vis[N],dis[N];
void add(int a,int b,int c){
    e[++idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx;
}
queue<int>q;
void spfa(int s){
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    q.push(s);
    vis[s]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=h[u];i!=-1;i=ne[i]){
            int v=e[i];
            if(dis[v]>dis[u]+w[i]){
                dis[v]=dis[u]+w[i];
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	memset(h,-1,sizeof h);
	cin>>n>>m;
	for(int i=1;i<=m;++i){
	    int a,b,c;
	    cin>>a>>b>>c;
	    add(a,b,c);
	}
	spfa(1);
	if(dis[n]==0x3f3f3f3f3f3f3f3f)cout<<"impossible"<<endl;
	else cout<<dis[n]<<endl;
	return 0;
} 
```
## SPFA判负环
```
/*https://www.acwing.com/problem/content/854/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,m;
const int N=2e3+10,M=1e4+10,inf=0x3f3f3f3f;
int e[M],w[M],nex[M],h[N],idx;
int dis[N],vis[N],cnt[N];
void add(int a,int b,int c){
    e[++idx]=b;
    w[idx]=c;
    nex[idx]=h[a];
    h[a]=idx;
}
queue<int>q;
bool spfa(){
    for(int i=1;i<=n;++i){
        dis[i]=inf;
        vis[i]=1;
        q.push(i);
    }
    dis[1]=0;
    
    while(q.size()){
        int u=q.front();
        vis[u]=0;
        q.pop();
        for(int i=h[u];i!=-1;i=nex[i]){
            int v=e[i];
            if(dis[v]>dis[u]+w[i]){
                dis[v]=dis[u]+w[i];
                cnt[v]=cnt[u]+1;
                if(cnt[v]>=n)return true;//true表示有负环
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                }
                /*
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                    cnt[v]=cnt[u]+1;
                    if(cnt[v]>=n)return true;//true表示有负环
                }
                */
            }
        }
    }
    return false;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>m;
	for(int i=0;i<=n+5;++i)h[i]=-1;
	for(int i=1;i<=m;++i){
	    int a,b,c;
	    cin>>a>>b>>c;
	    add(a,b,c);
	}
	if(!spfa()){
	    cout<<"No"<<endl;
	}else cout<<"Yes"<<endl;
	
	return 0;
} 
```
# 字符串
## 编辑距离
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=2e3+10;
typedef pair<int,int>pp;
int f[N][N];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    string s,t;
    cin>>s>>t;
    int n=s.size(),m=t.size();
    for(int i=0;i<=n;++i)
        f[i][0]=i;
    for(int i=0;i<=m;++i)
        f[0][i]=i;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            f[i][j]=min(f[i-1][j],f[i][j-1])+1;
            f[i][j]=min(f[i][j],f[i-1][j-1]+(s[i-1]!=t[j-1]));
            //cerr<<i<<" "<<j<<" "<<f[i][j]<<endl;
        }
    }
    cout<<f[n][m]<<endl;

    return 0;
}
```
## 后缀数组
```
/*https://www.luogu.com.cn/problem/P3809*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N=2e6+10;
char s[N];
int n,m;//n为后缀个数, m为桶的个数
int idd[N],cnt[N],sa[N],rk[N],oldrk[N],key1[N];
int height[N];
//桶数组rk[i],辅助数组idd[i],计数数组cnt[i]
bool cmp(int x, int y, int w) {
  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
}
void get_sa(){
    int i,p,w;
    for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
    for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;

    for (w = 1;; w <<= 1, m = p) {  // m=p 就是优化计数排序值域
        for (p = 0, i = n; i > n - w; --i) idd[++p] = i;
        for (i = 1; i <= n; ++i)
        if (sa[i] > w) idd[++p] = sa[i] - w;

        memset(cnt, 0, sizeof(cnt));
        for (i = 1; i <= n; ++i) ++cnt[key1[i] = rk[idd[i]]];
        // 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组

        for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; --i) sa[cnt[key1[i]]--] = idd[i];
        memcpy(oldrk + 1, rk + 1, n * sizeof(int));
        for (p = 0, i = 1; i <= n; ++i)
            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        if (p == n) {
            break;
        }
    }
}  
void get_height(){
    int i,j,k;
    for(i=1;i<=n;i++)rk[sa[i]]=i;
    for(i=1,k=0;i<=n;i++){ //枚举后缀i
        if(rk[i]==1)continue;//第一名height为0
        if(k)k--;//上一个后缀的height值减1
        int j=sa[rk[i]-1];//找出后缀i的前邻后缀j
        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k])k++;
        height[rk[i]]=k;
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);

    cin>>s+1;
    n=strlen(s+1); m=127;
    get_sa();
    //get_height();
    for(int i=1;i<=n;i++)cout<<sa[i]<<" "<<rk[i]<<" \n";
    //for(int i=1;i<=n;i++)cout<<height[i]<<" \n"[i==n];
    
    return 0;
}
```
## 回文树
```
/*https://www.luogu.com.cn/problem/P5496*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
typedef pair<int,int>pp;
int a[N];
struct PAM  {
    static constexpr int M = 26;
    int n;
    vector<array<int, M>> t;
    vector<int> link, len, s, trans, val, count;
    int cur, cnt;

    PAM(){}
    PAM(int x) {init(x);}

    void init(int x) {
        n = x + 2;
        t.assign(n, {});
        link.assign(n, 0);//fail指针
        count.assign(n, 0);
        val.assign(n, 0);//回文串个数
        len.assign(n, 0);
        s.assign(n, -1);
        trans.assign(n, 0);
        cur = 0;
        cnt = 2;
        len[1] = -1;
        link[0] = link[1] = 1;
    }


    int extend(int p, int c) {
        s[++cur] = c;
        int now = getfail(p);
        if (!t[now][c]) {
            int u = cnt++;
            len[u] = len[now] + 2;
            link[u] = t[getfail(link[now])][c];
            /*if (len[u] < 2)  {
                trans[u] = link[u]; 
            } else {
                int tmp = trans[now];
                while (s[cur - len[tmp] - 1] != s[cur] || ((len[tmp] + 2) << 1) > len[u]) tmp = link[tmp];
                //len[tmp]+2
                trans[u] = t[tmp][c];
                 val[u] = val[link[u]] + 1;

            }
            count[u] = 2 * len[trans[u]] == len[u];
            count[u] += count[link[u]];*/
            val[u] = val[link[u]] + 1;
            t[now][c] = u;
        }
        p = t[now][c];
        //val[p]++;
        return p;
    }

    int getfail(int x) {
        while (s[cur - len[x] - 1] != s[cur]) x = link[x];
        return x;
    }

} pam;
void solve()
{
    string str;
    cin>>str;
    int n=str.size();
    pam.init(n);
    int k=0;
    int p=1;
    for(int i=0;i<n;++i){
        char ch=(str[i]-97+k)%26+97;
        p=pam.extend(p,ch-'a');
        k=pam.val[p];
        cout<<k<<" ";
    }
    cout<<endl;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)	solve();
    return 0;
}
```
## 扩展KMP
```
/*https://www.luogu.com.cn/problem/P5410*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N=2e7+5;
string t,s;
int z[N],p[N];

void get_z(string s,int n){
    z[1]=n;
    for(int i=2,l,r=0;i<=n;i++){
        if(i<=r)z[i]=min(z[i-l+1],r-i+1);
        while(s[1+z[i]]==s[i+z[i]])z[i]++;
        if(i+z[i]-1>r)l=i,r=i+z[i]-1;
    }
}
void get_p(string s,int n,string t,int m){
    for(int i=1,l,r=0;i<=m;i++){
        if(i<=r)p[i]=min(z[i-l+1],r-i+1);
        while(1+p[i]<=n&&i+p[i]<=m&&s[1+p[i]]==t[i+p[i]])p[i]++;
        if(i+p[i]-1>r)l=i,r=i+p[i]-1;  
    }
}
std::vector<int> zFunction(std::string s) {//0-base jiangly
    int n = s.size();
    std::vector<int> z(n + 1);
    z[0] = n;
    for (int i = 1, j = 1; i < n; i++) {
        z[i] = std::max(0, std::min(j + z[j] - i, z[i - j]));
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] > j + z[j]) {
            j = i;
        }
    }
    return z;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>t>>s;
    t=' '+t,s=' '+s;
    int m=t.size()-1,n=s.size()-1;
    get_z(s,n);
    get_p(s,n,t,m);

    long long ans1=0,ans2=0;
    for(int i=1; i<=n; i++)
        ans1^=1LL*i*(z[i]+1);
    for(int i=1; i<=m; i++)
        ans2^=1LL*i*(p[i]+1);
    cout<<ans1<<endl<<ans2;
    return 0;
}
```
## 字符串哈希
```
/*https://www.acwing.com/problem/content/843/*/
/*https://www.acwing.com/problem/content/843/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
const int p=131,N=1e5+10;
int n,m;
char str[N];
int pp[N],h[N];
void init()
{
    for(int i=1;i<=n;++i){
        pp[i]=pp[i-1]*p;
        h[i]=h[i-1]*p+str[i];
        //cout<<i<<" "<<h[i]<<endl;
    }
}
int query(int l,int r){
	//cout<<l<<" "<<r<<" "<< " "<<h[l-1]*pp[r-l+1]<<" "<<h[r]-h[l-1]*pp[r-l+1]<<endl;
    return h[r]-h[l-1]*pp[r-l+1];
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>m;
    cin>>str+1;
    pp[0]=1;
    init();
    for(int i=1;i<=m;++i){
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if(query(l1,r1)==query(l2,r2))cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
	
	return 0;
} 
```
## AC自动机
```
/*https://www.luogu.com.cn/problem/P5357*/
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

typedef char chr;
typedef deque<int> dic;
const int maxN = 2e5;
const int maxS = 2e5;
const int maxT = 2e6;

int n;
chr s[maxS + 10];
chr t[maxT + 10];
int cnt[maxN + 10];

struct AhoCorasickAutomaton {
    struct Node {
        int son[30];
        int val;
        int fail;
        int head;
        dic index;
    } node[maxS + 10];

    struct Edge {
        int head;
        int next;
    } edge[maxS + 10];

    int root;
    int ncnt;
    int ecnt;

    void Insert(chr *str, int i) {
        int u = root;
        int m=strlen(str+1);
        for (int i = 1; i<=m; i++) {
        if (node[u].son[str[i] - 'a' + 1] == 0)
            node[u].son[str[i] - 'a' + 1] = ++ncnt;
        u = node[u].son[str[i] - 'a' + 1];
        }
        node[u].index.push_back(i);
        return;
    }

    void Build() {
        dic q;
        for (int i = 1; i <= 26; i++)
        if (node[root].son[i]) q.push_back(node[root].son[i]);
        while (!q.empty()) {
        int u = q.front();
        q.pop_front();
        for (int i = 1; i <= 26; i++) {
            if (node[u].son[i]) {
                node[node[u].son[i]].fail = node[node[u].fail].son[i];
                q.push_back(node[u].son[i]);
            } else {
                node[u].son[i] = node[node[u].fail].son[i];
            }
        }
        }
        return;
    }

    void Query(chr *str) {
        int u = root;
        int m=strlen(str+1);
        for (int i = 1; i<=m; i++) {
            u = node[u].son[str[i] - 'a' + 1];
            node[u].val++;
        }
        return;
    }

    void addEdge(int tail, int head) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].next = node[tail].head;
        node[tail].head = ecnt;
        return;
    }

    void DFS(int u) {
        for (int e = node[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            DFS(v);
            node[u].val += node[v].val;
        }
        for (auto i : node[u].index) cnt[i] += node[u].val;
        return;
    }

    void FailTree() {
        for (int u = 1; u <= ncnt; u++) addEdge(node[u].fail, u);
        DFS(root);
        return;
    }
} ACM;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> (s + 1);
        ACM.Insert(s, i);
    }
    ACM.Build();
    cin >> (t + 1);
    ACM.Query(t);
    ACM.FailTree();
    for (int i = 1; i <= n; i++)cout << cnt[i] << endl;
    return 0;
}
/*
#include <bits/stdc++.h>
#define maxn 8000001
using namespace std;
char s[maxn];
int n, cnt, vis[maxn], rev[maxn], indeg[maxn], ans;

struct trie_node {
    int son[27];
    int fail;
    int flag;
    int ans;

    void init() {
        memset(son, 0, sizeof(son));
        fail = flag = 0;
    }
} trie[maxn];

queue<int> q;

void init() {
    for (int i = 0; i <= cnt; i++) trie[i].init();
    for (int i = 1; i <= n; i++) vis[i] = 0;
    cnt = 1;
    ans = 0;
}

void insert(char *s, int num) {
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; i++) {
        int v = s[i] - 'a';
        if (!trie[u].son[v]) trie[u].son[v] = ++cnt;
        u = trie[u].son[v];
    }
    if (!trie[u].flag) trie[u].flag = num;
    rev[num] = trie[u].flag;
    return;
}

void getfail(void) {
    for (int i = 0; i < 26; i++) trie[0].son[i] = 1;
    q.push(1);
    trie[1].fail = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        int Fail = trie[u].fail;
        for (int i = 0; i < 26; i++) {
        int v = trie[u].son[i];
        if (!v) {
            trie[u].son[i] = trie[Fail].son[i];
            continue;
        }
        trie[v].fail = trie[Fail].son[i];
        indeg[trie[Fail].son[i]]++;
        q.push(v);
        }
    }
}

void topu() {
    for (int i = 1; i <= cnt; i++)
        if (!indeg[i]) q.push(i);
        while (!q.empty()) {
        int fr = q.front();
        q.pop();
        vis[trie[fr].flag] = trie[fr].ans;
        int u = trie[fr].fail;
        trie[u].ans += trie[fr].ans;
        if (!(--indeg[u])) q.push(u);
    }
}

void query(char *s) {
    int u = 1, len = strlen(s);
    for (int i = 0; i < len; i++) u = trie[u].son[s[i] - 'a'], trie[u].ans++;
}

int main() {
    scanf("%d", &n);
    init();
    for (int i = 1; i <= n; i++) scanf("%s", s), insert(s, i);
    getfail();
    scanf("%s", s);
    query(s);
    topu();
    for (int i = 1; i <= n; i++) cout << vis[rev[i]] << std::endl;
    return 0;
}*/
```
## Border
**引理1**：如果有一个border $k$ 长度大于 $s$ 的一半，可以得出得 $s$ 有周期 |$s$|−|$k$|
**引理2**：如果 p,q都为周期，则 gcd(p,q)也为周期
**引理3**：字符串$s$所有不小于 |$s$|一半的border构成一个等差数列
**引理4**：可以把字符串分成 log|$s$|段，每一段的border都是一个等差数列

在KMP匹配中，我们可以利用这个性质快速跳过一串border
具体而言，在一次跳border时，如果发现border长度不小于原串的一半，则接下来的border构成等差数列，直到一半以下（引理3）
可以直接跳到 $(x−(x/2/d)∗d)$ 处，即比一半大的第一个位置（整除）（网上博客直接跳到了 $x\%d+d$ 处，经过几道题检验也是对的，但不是很能理解）

一次至少跳一半，保证 $log$次以内可以跳完

## KMP
```
/*https://www.acwing.com/problem/content/description/833/*/
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;

class KMP
{
	vector<int> nx;
	string b;
public:
	KMP(string b)
	{
		this->b = b;
		int n = b.length();
		int j = 0;
		nx.resize(n);
		for (int i = 1; i < n; i++)
		{

			while (j > 0 && b[i] != b[j])
				j = nx[j - 1];
			if (b[i] == b[j])
				j++;
			nx[i] = j;
		}
	}
	int find(string a) // a中出现多少次b
	{
		int n = b.length(), m = a.length();
		int j = 0;
		int ans = 0;
		for (int i = 0; i < m; i++)
		{
			while (j > 0 && a[i] != b[j])
				j = nx[j - 1];
			if (a[i] == b[j])
				j++;
			if (j == n)
			{
				ans++;
				j = nx[j - 1];
			}
		}
		return ans;
	}
};
int m,n;
const int N=1e5+10,M=1e6+10;
int nex[N];
char p[N],s[M];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>p+1>>m>>s+1;//若无输入字符串长度先提前存储长度，否则Strlen函数将花费大量时间
	
	for(int i=2,j=0;i<=n;++i){
		while(j&&p[j+1]!=p[i])j=nex[j];
		if(p[j+1]==p[i])++j;
		nex[i]=j;
	}
	for(int i=1,j=0;i<=m;++i){
		while(j&&p[j+1]!=s[i])j=nex[j];
		if(p[j+1]==s[i])++j;
		if(j==n){
            //匹配成功
			cout<<i-n<<" ";
			j=nex[j];
		}
	}
	cout<<endl;
	return 0;
} 
/*3
aba
5
ababa*/
```
## Manacher
```
/*https://www.luogu.com.cn/problem/P3805*/
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
const int N=11e6+10;
string str,ss;
int d[N*2],ans=1;//ans包括#
inline void getd(string s){
    d[1]=1;
    for(int i=2,l,r=1;i<s.size();++i){
        if(i<=r)d[i]=min(d[r-i+l],r-i+1);
        while(s[i-d[i]]==s[i+d[i]])d[i]++;
        if(i+d[i]-1>r)l=i-d[i]+1,r=i+d[i]-1;
        ans=max(ans,d[i]);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>str;
    ss+='$';
    ss+='#';
    for(int i=0;i<str.size();++i){
        ss+=str[i];
        ss+='#';
    }
    getd(ss);
    cout<<ans-1<<endl;

    return 0;
}
```
## SAM
```
/*https://www.luogu.com.cn/problem/P3804*/
#include<bits/stdc++.h>
// #define int long long
using namespace std;
#define endl '\n'
typedef long long ll;
const int NN=2e6+10;
typedef pair<int,int>pp;
struct SAM {
    static const int M = 26, N = 1e6;
    struct Node {
        int len;
        int link;
        int sz;
        array<int, M> nxt;
        Node() = default;
    } t[2 * N];
    int cnt;
    SAM() {init();}
    int newNode() {
        int u = cnt++;
        t[u].len = t[u].link = 0;
        t[u].nxt.fill(0);
        t[u].sz=0;
        // t[u].sz=1;
        return u;
    }
    void init() {
        cnt = 0;
        newNode();
        newNode();
        t[0].nxt.fill(1);
        t[0].len = -1;
    }
    int extend(int p, int c) {
        // cerr<<p<<" "<<t[p].nxt[c]<<" "<<t[p].len<<" "<<t[p].link<<endl;
        if (t[p].nxt[c]) {
            int q = t[p].nxt[c];
            if (t[q].len == t[p].len + 1)
                return q;
            int r = newNode();
            t[r] = t[q];
            t[r].sz=0;
            t[r].len = t[p].len + 1;
            t[q].link = r;
            while (t[p].nxt[c] == q) {
                t[p].nxt[c] = r;
                p = t[p].link;
            }
            return r;
        }
        int cur = newNode();
        // cerr<<"cur:"<<cur<<" "<<cnt<<endl;
        t[cur].len = t[p].len + 1;
        t[cur].sz=1;

        while (!t[p].nxt[c]) {
            t[p].nxt[c] = cur;
            p = t[p].link;
        }
        t[cur].link = extend(p, c);
        // cerr<<"cur"<<cur<<" "<<t[cur].link<<" "<<t[cur].len<<endl;
        return cur;
    }
 
    int extend(int p, char c, char offset = 'a') {
        return extend(p, c - offset);
    }
    int nxt(int p, int x) {
        return t[p].nxt[x];
    }
    int nxt(int p, char c, char offset = 'a') {
        return nxt(p, c - 'a');
    }
    int link(int p) {
        return t[p].link;
    }
    int len(int p) {
        return t[p].len;
    }
    int size() {
        return cnt;
    }
} sam;
int h[NN],e[NN],nt[NN],idx;
void add(int a,int b){
    e[++idx]=b;
    nt[idx]=h[a];
    h[a]=idx;
}
ll res=0;
void dfs(int u){
    for(int i=h[u];i!=-1;i=nt[i]){
        dfs(e[i]);
        sam.t[u].sz+=sam.t[e[i]].sz;
    }
    if(sam.t[u].sz!=1){
        // cerr<<sam.t[u].sz<<" "<<sam.t[u].len<<endl;
        res=max(res,1ll*sam.t[u].sz*sam.t[u].len);
        // cerr<<res<<endl;
    }
}
void solve()
{
    memset(h,-1,sizeof h);
    string str;
    cin>>str;
    int n=str.size();
    vector<int>p(n+1);
    p[0]=1;
    for(int i=0;i<n;++i){
        // cerr<<str[i]<<endl;
        p[i+1]=sam.extend(p[i],str[i]);
        // cerr<<p[i+1]<<" "<<sam.t[p[i+1]].nxt[str[i]]<<" "<<sam.t[p[i+1]].len<<" "<<sam.t[p[i+1]].link<<endl;
        // cerr<<"cnt"<<sam.cnt<<endl;
    }

    for(int i=2;i<sam.size();++i){
        add(sam.link(i),i);
    }
    dfs(1);
    cout<<res<<endl;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T=1;
    // cin>>T;
    while(T--)	solve();
    return 0;
}
```
# 其他

## CDQ分治
```
#include<bits/stdc++.h>
using namespace std;
const int maxN = 1e5 + 10;
const int maxK = 2e5 + 10;

int n, k;

struct Element {
    int a, b, c;
    int cnt;
    int res;

    bool operator!=(Element other) {
        if (a != other.a) return true;
        if (b != other.b) return true;
        if (c != other.c) return true;
        return false;
    }
};

Element e[maxN];
Element ue[maxN];
int m, t;
int res[maxN];

struct BinaryIndexedTree {
    int node[maxK];

    int lowbit(int x) { return x & -x; }

    void Add(int pos, int val) {
        while (pos <= k) {
            node[pos] += val;
            pos += lowbit(pos);
        }
        return;
    }

    int Ask(int pos) {
        int res = 0;
        while (pos) {
            res += node[pos];
            pos -= lowbit(pos);
        }
        return res;
    }
} BIT;

bool cmpA(Element x, Element y) {
    if (x.a != y.a) return x.a < y.a;
    if (x.b != y.b) return x.b < y.b;
    return x.c < y.c;
}

bool cmpB(Element x, Element y) {
    if (x.b != y.b) return x.b < y.b;
    return x.c < y.c;
}

void CDQ(int l, int r) {
    if (l == r) return;
    int mid = (l + r) / 2;
    CDQ(l, mid);
    CDQ(mid + 1, r);
    sort(ue + l, ue + mid + 1, cmpB);
    sort(ue + mid + 1, ue + r + 1, cmpB);
    int i = l;
    int j = mid + 1;
    while (j <= r) {
        while (i <= mid && ue[i].b <= ue[j].b) {
        BIT.Add(ue[i].c, ue[i].cnt);
        i++;
        }
        ue[j].res += BIT.Ask(ue[j].c);
        j++;
    }
    for (int k = l; k < i; k++) BIT.Add(ue[k].c, -ue[k].cnt);
    return;
}

int main() {
    cin>>n>>k;
    for (int i = 1; i <= n; i++) cin>>e[i].a>>e[i].b>>e[i].c;
    sort(e + 1, e + n + 1, cmpA);
    for (int i = 1; i <= n; i++) {
        t++;
        if (e[i] != e[i + 1]) {
        m++;
        ue[m].a = e[i].a;
        ue[m].b = e[i].b;
        ue[m].c = e[i].c;
        ue[m].cnt = t;
        t = 0;
        }
    }
    CDQ(1, m);
    for (int i = 1; i <= m; i++) res[ue[i].res + ue[i].cnt - 1] += ue[i].cnt;
    for (int i = 0; i < n; i++) cout<<res[i]<<endl;
    return 0;
}
```
## 经典组合游戏
### Fibonacci 博弈
有一堆个数为n(n>=2)的石子，游戏双方轮流取石子，规则如下：
1)先手不能在第一次把所有的石子取完，至少取1颗；
2)之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。
约定取走最后一个石子的人为赢家，求必败态。
结论：当n为Fibonacci数的时候，必败。

### Wythoff 博弈
规则
有两堆石子，双方轮流取石子，每次必须只选择一种方法取石子：
1、取某一堆中的任意多个；
2、在两堆中同时取同样多个石子。
取完石子者获胜。
Beatty定理
若两个正无理数x,y满足$\frac{1}{x}+\frac{1}{y}=1$那么集合$P=\{p|p=\lfloor nx \rfloor,n \in \mathbb{N^+}\}$,$Q=\{q|q=\lfloor my \rfloor, m \in \mathbb{N^+}\}$是$\mathbb{N^+}$的一个划分，即$P\bigcup Q=\mathbb{N^+}$，且$P \bigcap Q=\emptyset$。
结论
设 $\alpha=(1+\sqrt5)/2,\beta =(3+\sqrt5)/2$，当且仅当初始状态不能表示为 $\{\lfloor n \alpha \rfloor ,  \lfloor n \beta \rfloor \},n \in \mathbb{N^+}$时先手胜。

### Chomp博弈
Chomp是一个双人游戏，有 $m*n$ 块曲奇饼排成一个矩形格状，称作棋盘。两个玩家轮流自选吃掉一块还剩下的曲奇饼，而且要把它右边和下面所有的曲奇饼都被取走（如果存在）。如果不吃左上角的那一块曲奇饼（位置记为(1, 1)）就没有其他选择的玩家为失败。
策梅洛定理
在二人参与的游戏中，如果满足游戏步骤有限、信息完备、每一步骤都是确定性，则或者先行一方有必胜策略，或者先行一方有必和策略，或者后行一方有必胜策略。

### 二分图博弈
二分图博弈是一类博弈模型，它可以被抽象为：给出一张二分图和起始点 $H$ ，A和B轮流操作，每次只能选与上个被选择的点（第一回合则是点 $H$ ）相邻的点，且不能选择已选择过的点，无法选点的人输掉。一个经典的二分图博弈模型是在国际象棋棋盘上，双方轮流移动一个士兵，不能走已经走过的格子，问谁先无路可走。

这类模型其实很好处理。考虑二分图的最大匹配，如果最大匹配一定包含 H ，那么先手必胜，否则先手必败。
## 逆序对
设两个数字之间本来有$k$对逆序对，两个数字(a<b)交换位置会产生$2*(r-l+1)-k-1$逆序对
## 哈希优化
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define endl '\n'
const int N=1e5+10;
int a[N];
struct custom_hash {
	static uint64_t splitmix64(uint64_t x) {
		// http://xorshift.di.unimi.it/splitmix64.c
		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    unordered_map<int,int,custom_hash>mp;
    unordered_set<int,custom_hash>st;
    
    return 0;
}







#include <functional>
// from boost (functional/hash):
// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template
template <typename T>
inline void hash_combine(std::size_t& seed, const T& val)
{
    seed ^= std::hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
// auxiliary generic functions to create a hash value using a seed
template <typename T>
inline void hash_val(std::size_t& seed, const T& val)
{
    hash_combine(seed, val);
}
template <typename T, typename... Types>
inline void hash_val(std::size_t& seed, const T& val, const Types&... args)
{
    hash_combine(seed, val);
    hash_val(seed, args...);
}

template <typename... Types>
inline std::size_t hash_val(const Types&... args)
{
    std::size_t seed = 0;
    hash_val(seed, args...);
    return seed;
}

struct pair_hash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2>& p) const
    {
        return hash_val(p.first, p.second);
    }
};

//#include <bits/stdc++.h>
//using namespace std;
//using ll = long long;

//int main()
//{
 //   unordered_map<pair<ll, ll>, ll, pair_hash> slopeCount;
 //   unordered_set<pair<ll, ll>, pair_hash> seen;
 //   return 0;
//}
```
## SG函数
```
/*https://atcoder.jp/contests/dp/tasks/dp_k*/
#include<bits/stdc++.h>//打表用
#define int long long
#define endl '\n' 
using namespace std;
int n,k;
const int N=110,K=1e5+10;
int a[N],sg[K];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>k;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=k;++i){
		set<int>s;
		for(int j=1;j<=n;++j){
			if(a[j]<=i)s.insert(sg[i-a[j]]);
		}
		while(s.count(sg[i]))sg[i]++;
		//cout<<i<<" "<<sg[i]<<endl;
	}
	if(sg[k]==0)cout<<"Second"<<endl;
	else cout<<"First"<<endl;
	return 0;
} 

/*https://www.acwing.com/problem/content/895/*/
//1、预处理递推
#include<bits/stdc++.h>
#define int long long
#define endl '\n' 
using namespace std;
int n,k,m;
const int N=110,K=1e5+10;
int a[N],h[N],sg[K],vis[K];
void init(int x){
    for(int i=1;i<=x;++i){
		set<int>s;
		for(int j=1;j<=n;++j){
			if(a[j]<=i)s.insert(sg[i-a[j]]);
		}
		while(s.count(sg[i]))sg[i]++;
		//cout<<i<<" "<<sg[i]<<endl;
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	cin>>m;
	int maxh=-1;
	for(int i=1;i<=m;++i){
	    cin>>h[i];
	    maxh=max(maxh,h[i]);
	}
	init(maxh);
	int res=0;
	for(int l=1;l<=m;++l){
        
    	res^=sg[h[l]];
    	//cout<<res<<endl;
	}
	if(res==0)cout<<"No"<<endl;
	else cout<<"Yes"<<endl;
	return 0;
} 

//2、递归+记忆化
/*#include<iostream>
#include<cstring>
#include<algorithm>
#include<set>

using namespace std;

const int N=110,M=10010;
int n,m;
int f[M],s[N];//s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值

int sg(int x)
{
    if(f[x]!=-1) return f[x];
    //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可
    set<int> S;
    //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)
    for(int i=0;i<m;i++)
    {
        int sum=s[i];
        if(x>=sum) S.insert(sg(x-sum));
        //先延伸到终点的sg值后,再从后往前排查出所有数的sg值
    }

    for(int i=0;;i++)
    //循环完之后可以进行选出最小的没有出现的自然数的操作
     if(!S.count(i))
      return f[x]=i;
}

int main()
{
    cin>>m;
    for(int i=0;i<m;i++)
    cin>>s[i];

    cin>>n;
    memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过

    int res=0;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        res^=sg(x);
        //观察异或值的变化,基本原理与Nim游戏相同
    }

    if(res) printf("Yes");
    else printf("No");

    return 0;
}*/
```